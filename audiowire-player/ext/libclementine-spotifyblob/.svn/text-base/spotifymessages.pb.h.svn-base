// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spotifymessages.proto

#ifndef PROTOBUF_spotifymessages_2eproto__INCLUDED
#define PROTOBUF_spotifymessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace pb {
namespace spotify {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_spotifymessages_2eproto();
void protobuf_AssignDesc_spotifymessages_2eproto();
void protobuf_ShutdownFile_spotifymessages_2eproto();

class LoginRequest;
class LoginResponse;
class Playlists;
class Playlists_Playlist;
class Track;
class Album;
class LoadPlaylistRequest;
class LoadPlaylistResponse;
class SyncPlaylistRequest;
class SyncPlaylistProgress;
class PlaybackRequest;
class PlaybackError;
class SearchRequest;
class SearchResponse;
class ImageRequest;
class ImageResponse;
class BrowseAlbumRequest;
class BrowseAlbumResponse;
class BrowseToplistRequest;
class BrowseToplistResponse;
class SeekRequest;
class PlaybackSettings;
class Message;

enum LoginResponse_Error {
  LoginResponse_Error_BadUsernameOrPassword = 1,
  LoginResponse_Error_UserBanned = 2,
  LoginResponse_Error_UserNeedsPremium = 3,
  LoginResponse_Error_Other = 4,
  LoginResponse_Error_ReloginFailed = 5
};
bool LoginResponse_Error_IsValid(int value);
const LoginResponse_Error LoginResponse_Error_Error_MIN = LoginResponse_Error_BadUsernameOrPassword;
const LoginResponse_Error LoginResponse_Error_Error_MAX = LoginResponse_Error_ReloginFailed;
const int LoginResponse_Error_Error_ARRAYSIZE = LoginResponse_Error_Error_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoginResponse_Error_descriptor();
inline const ::std::string& LoginResponse_Error_Name(LoginResponse_Error value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoginResponse_Error_descriptor(), value);
}
inline bool LoginResponse_Error_Parse(
    const ::std::string& name, LoginResponse_Error* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoginResponse_Error>(
    LoginResponse_Error_descriptor(), name, value);
}
enum BrowseToplistRequest_ToplistType {
  BrowseToplistRequest_ToplistType_Artists = 1,
  BrowseToplistRequest_ToplistType_Albums = 2,
  BrowseToplistRequest_ToplistType_Tracks = 3
};
bool BrowseToplistRequest_ToplistType_IsValid(int value);
const BrowseToplistRequest_ToplistType BrowseToplistRequest_ToplistType_ToplistType_MIN = BrowseToplistRequest_ToplistType_Artists;
const BrowseToplistRequest_ToplistType BrowseToplistRequest_ToplistType_ToplistType_MAX = BrowseToplistRequest_ToplistType_Tracks;
const int BrowseToplistRequest_ToplistType_ToplistType_ARRAYSIZE = BrowseToplistRequest_ToplistType_ToplistType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BrowseToplistRequest_ToplistType_descriptor();
inline const ::std::string& BrowseToplistRequest_ToplistType_Name(BrowseToplistRequest_ToplistType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BrowseToplistRequest_ToplistType_descriptor(), value);
}
inline bool BrowseToplistRequest_ToplistType_Parse(
    const ::std::string& name, BrowseToplistRequest_ToplistType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BrowseToplistRequest_ToplistType>(
    BrowseToplistRequest_ToplistType_descriptor(), name, value);
}
enum BrowseToplistRequest_Region {
  BrowseToplistRequest_Region_Everywhere = 1,
  BrowseToplistRequest_Region_User = 2
};
bool BrowseToplistRequest_Region_IsValid(int value);
const BrowseToplistRequest_Region BrowseToplistRequest_Region_Region_MIN = BrowseToplistRequest_Region_Everywhere;
const BrowseToplistRequest_Region BrowseToplistRequest_Region_Region_MAX = BrowseToplistRequest_Region_User;
const int BrowseToplistRequest_Region_Region_ARRAYSIZE = BrowseToplistRequest_Region_Region_MAX + 1;

const ::google::protobuf::EnumDescriptor* BrowseToplistRequest_Region_descriptor();
inline const ::std::string& BrowseToplistRequest_Region_Name(BrowseToplistRequest_Region value) {
  return ::google::protobuf::internal::NameOfEnum(
    BrowseToplistRequest_Region_descriptor(), value);
}
inline bool BrowseToplistRequest_Region_Parse(
    const ::std::string& name, BrowseToplistRequest_Region* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BrowseToplistRequest_Region>(
    BrowseToplistRequest_Region_descriptor(), name, value);
}
enum PlaylistType {
  Starred = 1,
  Inbox = 2,
  UserPlaylist = 3
};
bool PlaylistType_IsValid(int value);
const PlaylistType PlaylistType_MIN = Starred;
const PlaylistType PlaylistType_MAX = UserPlaylist;
const int PlaylistType_ARRAYSIZE = PlaylistType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PlaylistType_descriptor();
inline const ::std::string& PlaylistType_Name(PlaylistType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PlaylistType_descriptor(), value);
}
inline bool PlaylistType_Parse(
    const ::std::string& name, PlaylistType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlaylistType>(
    PlaylistType_descriptor(), name, value);
}
enum Bitrate {
  Bitrate96k = 1,
  Bitrate160k = 2,
  Bitrate320k = 3
};
bool Bitrate_IsValid(int value);
const Bitrate Bitrate_MIN = Bitrate96k;
const Bitrate Bitrate_MAX = Bitrate320k;
const int Bitrate_ARRAYSIZE = Bitrate_MAX + 1;

const ::google::protobuf::EnumDescriptor* Bitrate_descriptor();
inline const ::std::string& Bitrate_Name(Bitrate value) {
  return ::google::protobuf::internal::NameOfEnum(
    Bitrate_descriptor(), value);
}
inline bool Bitrate_Parse(
    const ::std::string& name, Bitrate* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Bitrate>(
    Bitrate_descriptor(), name, value);
}
// ===================================================================

class LoginRequest : public ::google::protobuf::Message {
 public:
  LoginRequest();
  virtual ~LoginRequest();
  
  LoginRequest(const LoginRequest& from);
  
  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();
  
  void Swap(LoginRequest* other);
  
  // implements Message ----------------------------------------------
  
  LoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // optional .pb.spotify.PlaybackSettings playback_settings = 3;
  inline bool has_playback_settings() const;
  inline void clear_playback_settings();
  static const int kPlaybackSettingsFieldNumber = 3;
  inline const ::pb::spotify::PlaybackSettings& playback_settings() const;
  inline ::pb::spotify::PlaybackSettings* mutable_playback_settings();
  inline ::pb::spotify::PlaybackSettings* release_playback_settings();
  
  // @@protoc_insertion_point(class_scope:pb.spotify.LoginRequest)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_playback_settings();
  inline void clear_has_playback_settings();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* username_;
  ::std::string* password_;
  ::pb::spotify::PlaybackSettings* playback_settings_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_spotifymessages_2eproto();
  friend void protobuf_AssignDesc_spotifymessages_2eproto();
  friend void protobuf_ShutdownFile_spotifymessages_2eproto();
  
  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::Message {
 public:
  LoginResponse();
  virtual ~LoginResponse();
  
  LoginResponse(const LoginResponse& from);
  
  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResponse& default_instance();
  
  void Swap(LoginResponse* other);
  
  // implements Message ----------------------------------------------
  
  LoginResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef LoginResponse_Error Error;
  static const Error BadUsernameOrPassword = LoginResponse_Error_BadUsernameOrPassword;
  static const Error UserBanned = LoginResponse_Error_UserBanned;
  static const Error UserNeedsPremium = LoginResponse_Error_UserNeedsPremium;
  static const Error Other = LoginResponse_Error_Other;
  static const Error ReloginFailed = LoginResponse_Error_ReloginFailed;
  static inline bool Error_IsValid(int value) {
    return LoginResponse_Error_IsValid(value);
  }
  static const Error Error_MIN =
    LoginResponse_Error_Error_MIN;
  static const Error Error_MAX =
    LoginResponse_Error_Error_MAX;
  static const int Error_ARRAYSIZE =
    LoginResponse_Error_Error_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Error_descriptor() {
    return LoginResponse_Error_descriptor();
  }
  static inline const ::std::string& Error_Name(Error value) {
    return LoginResponse_Error_Name(value);
  }
  static inline bool Error_Parse(const ::std::string& name,
      Error* value) {
    return LoginResponse_Error_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);
  
  // required string error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  
  // optional .pb.spotify.LoginResponse.Error error_code = 3 [default = Other];
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 3;
  inline ::pb::spotify::LoginResponse_Error error_code() const;
  inline void set_error_code(::pb::spotify::LoginResponse_Error value);
  
  // @@protoc_insertion_point(class_scope:pb.spotify.LoginResponse)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_error_code();
  inline void clear_has_error_code();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* error_;
  bool success_;
  int error_code_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_spotifymessages_2eproto();
  friend void protobuf_AssignDesc_spotifymessages_2eproto();
  friend void protobuf_ShutdownFile_spotifymessages_2eproto();
  
  void InitAsDefaultInstance();
  static LoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class Playlists_Playlist : public ::google::protobuf::Message {
 public:
  Playlists_Playlist();
  virtual ~Playlists_Playlist();
  
  Playlists_Playlist(const Playlists_Playlist& from);
  
  inline Playlists_Playlist& operator=(const Playlists_Playlist& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Playlists_Playlist& default_instance();
  
  void Swap(Playlists_Playlist* other);
  
  // implements Message ----------------------------------------------
  
  Playlists_Playlist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Playlists_Playlist& from);
  void MergeFrom(const Playlists_Playlist& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required bool is_offline = 3;
  inline bool has_is_offline() const;
  inline void clear_is_offline();
  static const int kIsOfflineFieldNumber = 3;
  inline bool is_offline() const;
  inline void set_is_offline(bool value);
  
  // optional int32 download_progress = 4;
  inline bool has_download_progress() const;
  inline void clear_download_progress();
  static const int kDownloadProgressFieldNumber = 4;
  inline ::google::protobuf::int32 download_progress() const;
  inline void set_download_progress(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:pb.spotify.Playlists.Playlist)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_is_offline();
  inline void clear_has_is_offline();
  inline void set_has_download_progress();
  inline void clear_has_download_progress();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 index_;
  bool is_offline_;
  ::google::protobuf::int32 download_progress_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_spotifymessages_2eproto();
  friend void protobuf_AssignDesc_spotifymessages_2eproto();
  friend void protobuf_ShutdownFile_spotifymessages_2eproto();
  
  void InitAsDefaultInstance();
  static Playlists_Playlist* default_instance_;
};
// -------------------------------------------------------------------

class Playlists : public ::google::protobuf::Message {
 public:
  Playlists();
  virtual ~Playlists();
  
  Playlists(const Playlists& from);
  
  inline Playlists& operator=(const Playlists& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Playlists& default_instance();
  
  void Swap(Playlists* other);
  
  // implements Message ----------------------------------------------
  
  Playlists* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Playlists& from);
  void MergeFrom(const Playlists& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Playlists_Playlist Playlist;
  
  // accessors -------------------------------------------------------
  
  // repeated .pb.spotify.Playlists.Playlist playlist = 1;
  inline int playlist_size() const;
  inline void clear_playlist();
  static const int kPlaylistFieldNumber = 1;
  inline const ::pb::spotify::Playlists_Playlist& playlist(int index) const;
  inline ::pb::spotify::Playlists_Playlist* mutable_playlist(int index);
  inline ::pb::spotify::Playlists_Playlist* add_playlist();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::spotify::Playlists_Playlist >&
      playlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::spotify::Playlists_Playlist >*
      mutable_playlist();
  
  // @@protoc_insertion_point(class_scope:pb.spotify.Playlists)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::pb::spotify::Playlists_Playlist > playlist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_spotifymessages_2eproto();
  friend void protobuf_AssignDesc_spotifymessages_2eproto();
  friend void protobuf_ShutdownFile_spotifymessages_2eproto();
  
  void InitAsDefaultInstance();
  static Playlists* default_instance_;
};
// -------------------------------------------------------------------

class Track : public ::google::protobuf::Message {
 public:
  Track();
  virtual ~Track();
  
  Track(const Track& from);
  
  inline Track& operator=(const Track& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Track& default_instance();
  
  void Swap(Track* other);
  
  // implements Message ----------------------------------------------
  
  Track* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Track& from);
  void MergeFrom(const Track& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool starred = 1;
  inline bool has_starred() const;
  inline void clear_starred();
  static const int kStarredFieldNumber = 1;
  inline bool starred() const;
  inline void set_starred(bool value);
  
  // required string title = 2;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 2;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  
  // repeated string artist = 3;
  inline int artist_size() const;
  inline void clear_artist();
  static const int kArtistFieldNumber = 3;
  inline const ::std::string& artist(int index) const;
  inline ::std::string* mutable_artist(int index);
  inline void set_artist(int index, const ::std::string& value);
  inline void set_artist(int index, const char* value);
  inline void set_artist(int index, const char* value, size_t size);
  inline ::std::string* add_artist();
  inline void add_artist(const ::std::string& value);
  inline void add_artist(const char* value);
  inline void add_artist(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& artist() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_artist();
  
  // required string album = 4;
  inline bool has_album() const;
  inline void clear_album();
  static const int kAlbumFieldNumber = 4;
  inline const ::std::string& album() const;
  inline void set_album(const ::std::string& value);
  inline void set_album(const char* value);
  inline void set_album(const char* value, size_t size);
  inline ::std::string* mutable_album();
  inline ::std::string* release_album();
  
  // required int32 duration_msec = 5;
  inline bool has_duration_msec() const;
  inline void clear_duration_msec();
  static const int kDurationMsecFieldNumber = 5;
  inline ::google::protobuf::int32 duration_msec() const;
  inline void set_duration_msec(::google::protobuf::int32 value);
  
  // required int32 popularity = 6;
  inline bool has_popularity() const;
  inline void clear_popularity();
  static const int kPopularityFieldNumber = 6;
  inline ::google::protobuf::int32 popularity() const;
  inline void set_popularity(::google::protobuf::int32 value);
  
  // required int32 disc = 7;
  inline bool has_disc() const;
  inline void clear_disc();
  static const int kDiscFieldNumber = 7;
  inline ::google::protobuf::int32 disc() const;
  inline void set_disc(::google::protobuf::int32 value);
  
  // required int32 track = 8;
  inline bool has_track() const;
  inline void clear_track();
  static const int kTrackFieldNumber = 8;
  inline ::google::protobuf::int32 track() const;
  inline void set_track(::google::protobuf::int32 value);
  
  // required int32 year = 9;
  inline bool has_year() const;
  inline void clear_year();
  static const int kYearFieldNumber = 9;
  inline ::google::protobuf::int32 year() const;
  inline void set_year(::google::protobuf::int32 value);
  
  // required string uri = 10;
  inline bool has_uri() const;
  inline void clear_uri();
  static const int kUriFieldNumber = 10;
  inline const ::std::string& uri() const;
  inline void set_uri(const ::std::string& value);
  inline void set_uri(const char* value);
  inline void set_uri(const char* value, size_t size);
  inline ::std::string* mutable_uri();
  inline ::std::string* release_uri();
  
  // required string album_art_id = 11;
  inline bool has_album_art_id() const;
  inline void clear_album_art_id();
  static const int kAlbumArtIdFieldNumber = 11;
  inline const ::std::string& album_art_id() const;
  inline void set_album_art_id(const ::std::string& value);
  inline void set_album_art_id(const char* value);
  inline void set_album_art_id(const char* value, size_t size);
  inline ::std::string* mutable_album_art_id();
  inline ::std::string* release_album_art_id();
  
  // @@protoc_insertion_point(class_scope:pb.spotify.Track)
 private:
  inline void set_has_starred();
  inline void clear_has_starred();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_album();
  inline void clear_has_album();
  inline void set_has_duration_msec();
  inline void clear_has_duration_msec();
  inline void set_has_popularity();
  inline void clear_has_popularity();
  inline void set_has_disc();
  inline void clear_has_disc();
  inline void set_has_track();
  inline void clear_has_track();
  inline void set_has_year();
  inline void clear_has_year();
  inline void set_has_uri();
  inline void clear_has_uri();
  inline void set_has_album_art_id();
  inline void clear_has_album_art_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* title_;
  ::google::protobuf::RepeatedPtrField< ::std::string> artist_;
  bool starred_;
  ::google::protobuf::int32 duration_msec_;
  ::std::string* album_;
  ::google::protobuf::int32 popularity_;
  ::google::protobuf::int32 disc_;
  ::google::protobuf::int32 track_;
  ::google::protobuf::int32 year_;
  ::std::string* uri_;
  ::std::string* album_art_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_spotifymessages_2eproto();
  friend void protobuf_AssignDesc_spotifymessages_2eproto();
  friend void protobuf_ShutdownFile_spotifymessages_2eproto();
  
  void InitAsDefaultInstance();
  static Track* default_instance_;
};
// -------------------------------------------------------------------

class Album : public ::google::protobuf::Message {
 public:
  Album();
  virtual ~Album();
  
  Album(const Album& from);
  
  inline Album& operator=(const Album& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Album& default_instance();
  
  void Swap(Album* other);
  
  // implements Message ----------------------------------------------
  
  Album* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Album& from);
  void MergeFrom(const Album& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .pb.spotify.Track metadata = 1;
  inline bool has_metadata() const;
  inline void clear_metadata();
  static const int kMetadataFieldNumber = 1;
  inline const ::pb::spotify::Track& metadata() const;
  inline ::pb::spotify::Track* mutable_metadata();
  inline ::pb::spotify::Track* release_metadata();
  
  // repeated .pb.spotify.Track track = 2;
  inline int track_size() const;
  inline void clear_track();
  static const int kTrackFieldNumber = 2;
  inline const ::pb::spotify::Track& track(int index) const;
  inline ::pb::spotify::Track* mutable_track(int index);
  inline ::pb::spotify::Track* add_track();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::spotify::Track >&
      track() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::spotify::Track >*
      mutable_track();
  
  // @@protoc_insertion_point(class_scope:pb.spotify.Album)
 private:
  inline void set_has_metadata();
  inline void clear_has_metadata();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::pb::spotify::Track* metadata_;
  ::google::protobuf::RepeatedPtrField< ::pb::spotify::Track > track_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_spotifymessages_2eproto();
  friend void protobuf_AssignDesc_spotifymessages_2eproto();
  friend void protobuf_ShutdownFile_spotifymessages_2eproto();
  
  void InitAsDefaultInstance();
  static Album* default_instance_;
};
// -------------------------------------------------------------------

class LoadPlaylistRequest : public ::google::protobuf::Message {
 public:
  LoadPlaylistRequest();
  virtual ~LoadPlaylistRequest();
  
  LoadPlaylistRequest(const LoadPlaylistRequest& from);
  
  inline LoadPlaylistRequest& operator=(const LoadPlaylistRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadPlaylistRequest& default_instance();
  
  void Swap(LoadPlaylistRequest* other);
  
  // implements Message ----------------------------------------------
  
  LoadPlaylistRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoadPlaylistRequest& from);
  void MergeFrom(const LoadPlaylistRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .pb.spotify.PlaylistType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline pb::spotify::PlaylistType type() const;
  inline void set_type(pb::spotify::PlaylistType value);
  
  // optional int32 user_playlist_index = 2;
  inline bool has_user_playlist_index() const;
  inline void clear_user_playlist_index();
  static const int kUserPlaylistIndexFieldNumber = 2;
  inline ::google::protobuf::int32 user_playlist_index() const;
  inline void set_user_playlist_index(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:pb.spotify.LoadPlaylistRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_user_playlist_index();
  inline void clear_has_user_playlist_index();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int type_;
  ::google::protobuf::int32 user_playlist_index_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_spotifymessages_2eproto();
  friend void protobuf_AssignDesc_spotifymessages_2eproto();
  friend void protobuf_ShutdownFile_spotifymessages_2eproto();
  
  void InitAsDefaultInstance();
  static LoadPlaylistRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoadPlaylistResponse : public ::google::protobuf::Message {
 public:
  LoadPlaylistResponse();
  virtual ~LoadPlaylistResponse();
  
  LoadPlaylistResponse(const LoadPlaylistResponse& from);
  
  inline LoadPlaylistResponse& operator=(const LoadPlaylistResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadPlaylistResponse& default_instance();
  
  void Swap(LoadPlaylistResponse* other);
  
  // implements Message ----------------------------------------------
  
  LoadPlaylistResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoadPlaylistResponse& from);
  void MergeFrom(const LoadPlaylistResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .pb.spotify.LoadPlaylistRequest request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::pb::spotify::LoadPlaylistRequest& request() const;
  inline ::pb::spotify::LoadPlaylistRequest* mutable_request();
  inline ::pb::spotify::LoadPlaylistRequest* release_request();
  
  // repeated .pb.spotify.Track track = 2;
  inline int track_size() const;
  inline void clear_track();
  static const int kTrackFieldNumber = 2;
  inline const ::pb::spotify::Track& track(int index) const;
  inline ::pb::spotify::Track* mutable_track(int index);
  inline ::pb::spotify::Track* add_track();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::spotify::Track >&
      track() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::spotify::Track >*
      mutable_track();
  
  // @@protoc_insertion_point(class_scope:pb.spotify.LoadPlaylistResponse)
 private:
  inline void set_has_request();
  inline void clear_has_request();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::pb::spotify::LoadPlaylistRequest* request_;
  ::google::protobuf::RepeatedPtrField< ::pb::spotify::Track > track_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_spotifymessages_2eproto();
  friend void protobuf_AssignDesc_spotifymessages_2eproto();
  friend void protobuf_ShutdownFile_spotifymessages_2eproto();
  
  void InitAsDefaultInstance();
  static LoadPlaylistResponse* default_instance_;
};
// -------------------------------------------------------------------

class SyncPlaylistRequest : public ::google::protobuf::Message {
 public:
  SyncPlaylistRequest();
  virtual ~SyncPlaylistRequest();
  
  SyncPlaylistRequest(const SyncPlaylistRequest& from);
  
  inline SyncPlaylistRequest& operator=(const SyncPlaylistRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncPlaylistRequest& default_instance();
  
  void Swap(SyncPlaylistRequest* other);
  
  // implements Message ----------------------------------------------
  
  SyncPlaylistRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SyncPlaylistRequest& from);
  void MergeFrom(const SyncPlaylistRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .pb.spotify.LoadPlaylistRequest request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::pb::spotify::LoadPlaylistRequest& request() const;
  inline ::pb::spotify::LoadPlaylistRequest* mutable_request();
  inline ::pb::spotify::LoadPlaylistRequest* release_request();
  
  // required bool offline_sync = 2;
  inline bool has_offline_sync() const;
  inline void clear_offline_sync();
  static const int kOfflineSyncFieldNumber = 2;
  inline bool offline_sync() const;
  inline void set_offline_sync(bool value);
  
  // @@protoc_insertion_point(class_scope:pb.spotify.SyncPlaylistRequest)
 private:
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_offline_sync();
  inline void clear_has_offline_sync();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::pb::spotify::LoadPlaylistRequest* request_;
  bool offline_sync_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_spotifymessages_2eproto();
  friend void protobuf_AssignDesc_spotifymessages_2eproto();
  friend void protobuf_ShutdownFile_spotifymessages_2eproto();
  
  void InitAsDefaultInstance();
  static SyncPlaylistRequest* default_instance_;
};
// -------------------------------------------------------------------

class SyncPlaylistProgress : public ::google::protobuf::Message {
 public:
  SyncPlaylistProgress();
  virtual ~SyncPlaylistProgress();
  
  SyncPlaylistProgress(const SyncPlaylistProgress& from);
  
  inline SyncPlaylistProgress& operator=(const SyncPlaylistProgress& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncPlaylistProgress& default_instance();
  
  void Swap(SyncPlaylistProgress* other);
  
  // implements Message ----------------------------------------------
  
  SyncPlaylistProgress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SyncPlaylistProgress& from);
  void MergeFrom(const SyncPlaylistProgress& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .pb.spotify.LoadPlaylistRequest request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::pb::spotify::LoadPlaylistRequest& request() const;
  inline ::pb::spotify::LoadPlaylistRequest* mutable_request();
  inline ::pb::spotify::LoadPlaylistRequest* release_request();
  
  // required int32 sync_progress = 2;
  inline bool has_sync_progress() const;
  inline void clear_sync_progress();
  static const int kSyncProgressFieldNumber = 2;
  inline ::google::protobuf::int32 sync_progress() const;
  inline void set_sync_progress(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:pb.spotify.SyncPlaylistProgress)
 private:
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_sync_progress();
  inline void clear_has_sync_progress();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::pb::spotify::LoadPlaylistRequest* request_;
  ::google::protobuf::int32 sync_progress_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_spotifymessages_2eproto();
  friend void protobuf_AssignDesc_spotifymessages_2eproto();
  friend void protobuf_ShutdownFile_spotifymessages_2eproto();
  
  void InitAsDefaultInstance();
  static SyncPlaylistProgress* default_instance_;
};
// -------------------------------------------------------------------

class PlaybackRequest : public ::google::protobuf::Message {
 public:
  PlaybackRequest();
  virtual ~PlaybackRequest();
  
  PlaybackRequest(const PlaybackRequest& from);
  
  inline PlaybackRequest& operator=(const PlaybackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlaybackRequest& default_instance();
  
  void Swap(PlaybackRequest* other);
  
  // implements Message ----------------------------------------------
  
  PlaybackRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlaybackRequest& from);
  void MergeFrom(const PlaybackRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string track_uri = 1;
  inline bool has_track_uri() const;
  inline void clear_track_uri();
  static const int kTrackUriFieldNumber = 1;
  inline const ::std::string& track_uri() const;
  inline void set_track_uri(const ::std::string& value);
  inline void set_track_uri(const char* value);
  inline void set_track_uri(const char* value, size_t size);
  inline ::std::string* mutable_track_uri();
  inline ::std::string* release_track_uri();
  
  // required int32 media_port = 2;
  inline bool has_media_port() const;
  inline void clear_media_port();
  static const int kMediaPortFieldNumber = 2;
  inline ::google::protobuf::int32 media_port() const;
  inline void set_media_port(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:pb.spotify.PlaybackRequest)
 private:
  inline void set_has_track_uri();
  inline void clear_has_track_uri();
  inline void set_has_media_port();
  inline void clear_has_media_port();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* track_uri_;
  ::google::protobuf::int32 media_port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_spotifymessages_2eproto();
  friend void protobuf_AssignDesc_spotifymessages_2eproto();
  friend void protobuf_ShutdownFile_spotifymessages_2eproto();
  
  void InitAsDefaultInstance();
  static PlaybackRequest* default_instance_;
};
// -------------------------------------------------------------------

class PlaybackError : public ::google::protobuf::Message {
 public:
  PlaybackError();
  virtual ~PlaybackError();
  
  PlaybackError(const PlaybackError& from);
  
  inline PlaybackError& operator=(const PlaybackError& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlaybackError& default_instance();
  
  void Swap(PlaybackError* other);
  
  // implements Message ----------------------------------------------
  
  PlaybackError* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlaybackError& from);
  void MergeFrom(const PlaybackError& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  
  // @@protoc_insertion_point(class_scope:pb.spotify.PlaybackError)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_spotifymessages_2eproto();
  friend void protobuf_AssignDesc_spotifymessages_2eproto();
  friend void protobuf_ShutdownFile_spotifymessages_2eproto();
  
  void InitAsDefaultInstance();
  static PlaybackError* default_instance_;
};
// -------------------------------------------------------------------

class SearchRequest : public ::google::protobuf::Message {
 public:
  SearchRequest();
  virtual ~SearchRequest();
  
  SearchRequest(const SearchRequest& from);
  
  inline SearchRequest& operator=(const SearchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchRequest& default_instance();
  
  void Swap(SearchRequest* other);
  
  // implements Message ----------------------------------------------
  
  SearchRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchRequest& from);
  void MergeFrom(const SearchRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string query = 1;
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 1;
  inline const ::std::string& query() const;
  inline void set_query(const ::std::string& value);
  inline void set_query(const char* value);
  inline void set_query(const char* value, size_t size);
  inline ::std::string* mutable_query();
  inline ::std::string* release_query();
  
  // optional int32 limit = 2 [default = 250];
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 2;
  inline ::google::protobuf::int32 limit() const;
  inline void set_limit(::google::protobuf::int32 value);
  
  // optional int32 limit_album = 3 [default = 0];
  inline bool has_limit_album() const;
  inline void clear_limit_album();
  static const int kLimitAlbumFieldNumber = 3;
  inline ::google::protobuf::int32 limit_album() const;
  inline void set_limit_album(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:pb.spotify.SearchRequest)
 private:
  inline void set_has_query();
  inline void clear_has_query();
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_limit_album();
  inline void clear_has_limit_album();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* query_;
  ::google::protobuf::int32 limit_;
  ::google::protobuf::int32 limit_album_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_spotifymessages_2eproto();
  friend void protobuf_AssignDesc_spotifymessages_2eproto();
  friend void protobuf_ShutdownFile_spotifymessages_2eproto();
  
  void InitAsDefaultInstance();
  static SearchRequest* default_instance_;
};
// -------------------------------------------------------------------

class SearchResponse : public ::google::protobuf::Message {
 public:
  SearchResponse();
  virtual ~SearchResponse();
  
  SearchResponse(const SearchResponse& from);
  
  inline SearchResponse& operator=(const SearchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchResponse& default_instance();
  
  void Swap(SearchResponse* other);
  
  // implements Message ----------------------------------------------
  
  SearchResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchResponse& from);
  void MergeFrom(const SearchResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .pb.spotify.SearchRequest request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::pb::spotify::SearchRequest& request() const;
  inline ::pb::spotify::SearchRequest* mutable_request();
  inline ::pb::spotify::SearchRequest* release_request();
  
  // repeated .pb.spotify.Track result = 2;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::pb::spotify::Track& result(int index) const;
  inline ::pb::spotify::Track* mutable_result(int index);
  inline ::pb::spotify::Track* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::spotify::Track >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::spotify::Track >*
      mutable_result();
  
  // optional int32 total_tracks = 3;
  inline bool has_total_tracks() const;
  inline void clear_total_tracks();
  static const int kTotalTracksFieldNumber = 3;
  inline ::google::protobuf::int32 total_tracks() const;
  inline void set_total_tracks(::google::protobuf::int32 value);
  
  // optional string did_you_mean = 4;
  inline bool has_did_you_mean() const;
  inline void clear_did_you_mean();
  static const int kDidYouMeanFieldNumber = 4;
  inline const ::std::string& did_you_mean() const;
  inline void set_did_you_mean(const ::std::string& value);
  inline void set_did_you_mean(const char* value);
  inline void set_did_you_mean(const char* value, size_t size);
  inline ::std::string* mutable_did_you_mean();
  inline ::std::string* release_did_you_mean();
  
  // optional string error = 5;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 5;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  
  // repeated .pb.spotify.Album album = 7;
  inline int album_size() const;
  inline void clear_album();
  static const int kAlbumFieldNumber = 7;
  inline const ::pb::spotify::Album& album(int index) const;
  inline ::pb::spotify::Album* mutable_album(int index);
  inline ::pb::spotify::Album* add_album();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::spotify::Album >&
      album() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::spotify::Album >*
      mutable_album();
  
  // @@protoc_insertion_point(class_scope:pb.spotify.SearchResponse)
 private:
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_total_tracks();
  inline void clear_has_total_tracks();
  inline void set_has_did_you_mean();
  inline void clear_has_did_you_mean();
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::pb::spotify::SearchRequest* request_;
  ::google::protobuf::RepeatedPtrField< ::pb::spotify::Track > result_;
  ::std::string* did_you_mean_;
  ::std::string* error_;
  ::google::protobuf::RepeatedPtrField< ::pb::spotify::Album > album_;
  ::google::protobuf::int32 total_tracks_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_spotifymessages_2eproto();
  friend void protobuf_AssignDesc_spotifymessages_2eproto();
  friend void protobuf_ShutdownFile_spotifymessages_2eproto();
  
  void InitAsDefaultInstance();
  static SearchResponse* default_instance_;
};
// -------------------------------------------------------------------

class ImageRequest : public ::google::protobuf::Message {
 public:
  ImageRequest();
  virtual ~ImageRequest();
  
  ImageRequest(const ImageRequest& from);
  
  inline ImageRequest& operator=(const ImageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageRequest& default_instance();
  
  void Swap(ImageRequest* other);
  
  // implements Message ----------------------------------------------
  
  ImageRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageRequest& from);
  void MergeFrom(const ImageRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // @@protoc_insertion_point(class_scope:pb.spotify.ImageRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_spotifymessages_2eproto();
  friend void protobuf_AssignDesc_spotifymessages_2eproto();
  friend void protobuf_ShutdownFile_spotifymessages_2eproto();
  
  void InitAsDefaultInstance();
  static ImageRequest* default_instance_;
};
// -------------------------------------------------------------------

class ImageResponse : public ::google::protobuf::Message {
 public:
  ImageResponse();
  virtual ~ImageResponse();
  
  ImageResponse(const ImageResponse& from);
  
  inline ImageResponse& operator=(const ImageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageResponse& default_instance();
  
  void Swap(ImageResponse* other);
  
  // implements Message ----------------------------------------------
  
  ImageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageResponse& from);
  void MergeFrom(const ImageResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // optional bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // @@protoc_insertion_point(class_scope:pb.spotify.ImageResponse)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_data();
  inline void clear_has_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::std::string* data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_spotifymessages_2eproto();
  friend void protobuf_AssignDesc_spotifymessages_2eproto();
  friend void protobuf_ShutdownFile_spotifymessages_2eproto();
  
  void InitAsDefaultInstance();
  static ImageResponse* default_instance_;
};
// -------------------------------------------------------------------

class BrowseAlbumRequest : public ::google::protobuf::Message {
 public:
  BrowseAlbumRequest();
  virtual ~BrowseAlbumRequest();
  
  BrowseAlbumRequest(const BrowseAlbumRequest& from);
  
  inline BrowseAlbumRequest& operator=(const BrowseAlbumRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BrowseAlbumRequest& default_instance();
  
  void Swap(BrowseAlbumRequest* other);
  
  // implements Message ----------------------------------------------
  
  BrowseAlbumRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BrowseAlbumRequest& from);
  void MergeFrom(const BrowseAlbumRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string uri = 1;
  inline bool has_uri() const;
  inline void clear_uri();
  static const int kUriFieldNumber = 1;
  inline const ::std::string& uri() const;
  inline void set_uri(const ::std::string& value);
  inline void set_uri(const char* value);
  inline void set_uri(const char* value, size_t size);
  inline ::std::string* mutable_uri();
  inline ::std::string* release_uri();
  
  // @@protoc_insertion_point(class_scope:pb.spotify.BrowseAlbumRequest)
 private:
  inline void set_has_uri();
  inline void clear_has_uri();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uri_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_spotifymessages_2eproto();
  friend void protobuf_AssignDesc_spotifymessages_2eproto();
  friend void protobuf_ShutdownFile_spotifymessages_2eproto();
  
  void InitAsDefaultInstance();
  static BrowseAlbumRequest* default_instance_;
};
// -------------------------------------------------------------------

class BrowseAlbumResponse : public ::google::protobuf::Message {
 public:
  BrowseAlbumResponse();
  virtual ~BrowseAlbumResponse();
  
  BrowseAlbumResponse(const BrowseAlbumResponse& from);
  
  inline BrowseAlbumResponse& operator=(const BrowseAlbumResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BrowseAlbumResponse& default_instance();
  
  void Swap(BrowseAlbumResponse* other);
  
  // implements Message ----------------------------------------------
  
  BrowseAlbumResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BrowseAlbumResponse& from);
  void MergeFrom(const BrowseAlbumResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string uri = 1;
  inline bool has_uri() const;
  inline void clear_uri();
  static const int kUriFieldNumber = 1;
  inline const ::std::string& uri() const;
  inline void set_uri(const ::std::string& value);
  inline void set_uri(const char* value);
  inline void set_uri(const char* value, size_t size);
  inline ::std::string* mutable_uri();
  inline ::std::string* release_uri();
  
  // repeated .pb.spotify.Track track = 2;
  inline int track_size() const;
  inline void clear_track();
  static const int kTrackFieldNumber = 2;
  inline const ::pb::spotify::Track& track(int index) const;
  inline ::pb::spotify::Track* mutable_track(int index);
  inline ::pb::spotify::Track* add_track();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::spotify::Track >&
      track() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::spotify::Track >*
      mutable_track();
  
  // @@protoc_insertion_point(class_scope:pb.spotify.BrowseAlbumResponse)
 private:
  inline void set_has_uri();
  inline void clear_has_uri();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uri_;
  ::google::protobuf::RepeatedPtrField< ::pb::spotify::Track > track_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_spotifymessages_2eproto();
  friend void protobuf_AssignDesc_spotifymessages_2eproto();
  friend void protobuf_ShutdownFile_spotifymessages_2eproto();
  
  void InitAsDefaultInstance();
  static BrowseAlbumResponse* default_instance_;
};
// -------------------------------------------------------------------

class BrowseToplistRequest : public ::google::protobuf::Message {
 public:
  BrowseToplistRequest();
  virtual ~BrowseToplistRequest();
  
  BrowseToplistRequest(const BrowseToplistRequest& from);
  
  inline BrowseToplistRequest& operator=(const BrowseToplistRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BrowseToplistRequest& default_instance();
  
  void Swap(BrowseToplistRequest* other);
  
  // implements Message ----------------------------------------------
  
  BrowseToplistRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BrowseToplistRequest& from);
  void MergeFrom(const BrowseToplistRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef BrowseToplistRequest_ToplistType ToplistType;
  static const ToplistType Artists = BrowseToplistRequest_ToplistType_Artists;
  static const ToplistType Albums = BrowseToplistRequest_ToplistType_Albums;
  static const ToplistType Tracks = BrowseToplistRequest_ToplistType_Tracks;
  static inline bool ToplistType_IsValid(int value) {
    return BrowseToplistRequest_ToplistType_IsValid(value);
  }
  static const ToplistType ToplistType_MIN =
    BrowseToplistRequest_ToplistType_ToplistType_MIN;
  static const ToplistType ToplistType_MAX =
    BrowseToplistRequest_ToplistType_ToplistType_MAX;
  static const int ToplistType_ARRAYSIZE =
    BrowseToplistRequest_ToplistType_ToplistType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ToplistType_descriptor() {
    return BrowseToplistRequest_ToplistType_descriptor();
  }
  static inline const ::std::string& ToplistType_Name(ToplistType value) {
    return BrowseToplistRequest_ToplistType_Name(value);
  }
  static inline bool ToplistType_Parse(const ::std::string& name,
      ToplistType* value) {
    return BrowseToplistRequest_ToplistType_Parse(name, value);
  }
  
  typedef BrowseToplistRequest_Region Region;
  static const Region Everywhere = BrowseToplistRequest_Region_Everywhere;
  static const Region User = BrowseToplistRequest_Region_User;
  static inline bool Region_IsValid(int value) {
    return BrowseToplistRequest_Region_IsValid(value);
  }
  static const Region Region_MIN =
    BrowseToplistRequest_Region_Region_MIN;
  static const Region Region_MAX =
    BrowseToplistRequest_Region_Region_MAX;
  static const int Region_ARRAYSIZE =
    BrowseToplistRequest_Region_Region_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Region_descriptor() {
    return BrowseToplistRequest_Region_descriptor();
  }
  static inline const ::std::string& Region_Name(Region value) {
    return BrowseToplistRequest_Region_Name(value);
  }
  static inline bool Region_Parse(const ::std::string& name,
      Region* value) {
    return BrowseToplistRequest_Region_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .pb.spotify.BrowseToplistRequest.ToplistType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::pb::spotify::BrowseToplistRequest_ToplistType type() const;
  inline void set_type(::pb::spotify::BrowseToplistRequest_ToplistType value);
  
  // optional .pb.spotify.BrowseToplistRequest.Region region = 2 [default = Everywhere];
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 2;
  inline ::pb::spotify::BrowseToplistRequest_Region region() const;
  inline void set_region(::pb::spotify::BrowseToplistRequest_Region value);
  
  // optional string username = 3;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 3;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // @@protoc_insertion_point(class_scope:pb.spotify.BrowseToplistRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_username();
  inline void clear_has_username();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int type_;
  int region_;
  ::std::string* username_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_spotifymessages_2eproto();
  friend void protobuf_AssignDesc_spotifymessages_2eproto();
  friend void protobuf_ShutdownFile_spotifymessages_2eproto();
  
  void InitAsDefaultInstance();
  static BrowseToplistRequest* default_instance_;
};
// -------------------------------------------------------------------

class BrowseToplistResponse : public ::google::protobuf::Message {
 public:
  BrowseToplistResponse();
  virtual ~BrowseToplistResponse();
  
  BrowseToplistResponse(const BrowseToplistResponse& from);
  
  inline BrowseToplistResponse& operator=(const BrowseToplistResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BrowseToplistResponse& default_instance();
  
  void Swap(BrowseToplistResponse* other);
  
  // implements Message ----------------------------------------------
  
  BrowseToplistResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BrowseToplistResponse& from);
  void MergeFrom(const BrowseToplistResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .pb.spotify.BrowseToplistRequest request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::pb::spotify::BrowseToplistRequest& request() const;
  inline ::pb::spotify::BrowseToplistRequest* mutable_request();
  inline ::pb::spotify::BrowseToplistRequest* release_request();
  
  // repeated .pb.spotify.Track track = 2;
  inline int track_size() const;
  inline void clear_track();
  static const int kTrackFieldNumber = 2;
  inline const ::pb::spotify::Track& track(int index) const;
  inline ::pb::spotify::Track* mutable_track(int index);
  inline ::pb::spotify::Track* add_track();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::spotify::Track >&
      track() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::spotify::Track >*
      mutable_track();
  
  // repeated .pb.spotify.Album album = 3;
  inline int album_size() const;
  inline void clear_album();
  static const int kAlbumFieldNumber = 3;
  inline const ::pb::spotify::Album& album(int index) const;
  inline ::pb::spotify::Album* mutable_album(int index);
  inline ::pb::spotify::Album* add_album();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::spotify::Album >&
      album() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::spotify::Album >*
      mutable_album();
  
  // @@protoc_insertion_point(class_scope:pb.spotify.BrowseToplistResponse)
 private:
  inline void set_has_request();
  inline void clear_has_request();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::pb::spotify::BrowseToplistRequest* request_;
  ::google::protobuf::RepeatedPtrField< ::pb::spotify::Track > track_;
  ::google::protobuf::RepeatedPtrField< ::pb::spotify::Album > album_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_spotifymessages_2eproto();
  friend void protobuf_AssignDesc_spotifymessages_2eproto();
  friend void protobuf_ShutdownFile_spotifymessages_2eproto();
  
  void InitAsDefaultInstance();
  static BrowseToplistResponse* default_instance_;
};
// -------------------------------------------------------------------

class SeekRequest : public ::google::protobuf::Message {
 public:
  SeekRequest();
  virtual ~SeekRequest();
  
  SeekRequest(const SeekRequest& from);
  
  inline SeekRequest& operator=(const SeekRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeekRequest& default_instance();
  
  void Swap(SeekRequest* other);
  
  // implements Message ----------------------------------------------
  
  SeekRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SeekRequest& from);
  void MergeFrom(const SeekRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int64 offset_bytes = 1;
  inline bool has_offset_bytes() const;
  inline void clear_offset_bytes();
  static const int kOffsetBytesFieldNumber = 1;
  inline ::google::protobuf::int64 offset_bytes() const;
  inline void set_offset_bytes(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:pb.spotify.SeekRequest)
 private:
  inline void set_has_offset_bytes();
  inline void clear_has_offset_bytes();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 offset_bytes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_spotifymessages_2eproto();
  friend void protobuf_AssignDesc_spotifymessages_2eproto();
  friend void protobuf_ShutdownFile_spotifymessages_2eproto();
  
  void InitAsDefaultInstance();
  static SeekRequest* default_instance_;
};
// -------------------------------------------------------------------

class PlaybackSettings : public ::google::protobuf::Message {
 public:
  PlaybackSettings();
  virtual ~PlaybackSettings();
  
  PlaybackSettings(const PlaybackSettings& from);
  
  inline PlaybackSettings& operator=(const PlaybackSettings& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlaybackSettings& default_instance();
  
  void Swap(PlaybackSettings* other);
  
  // implements Message ----------------------------------------------
  
  PlaybackSettings* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlaybackSettings& from);
  void MergeFrom(const PlaybackSettings& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .pb.spotify.Bitrate bitrate = 1 [default = Bitrate320k];
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 1;
  inline pb::spotify::Bitrate bitrate() const;
  inline void set_bitrate(pb::spotify::Bitrate value);
  
  // optional bool volume_normalisation = 2 [default = false];
  inline bool has_volume_normalisation() const;
  inline void clear_volume_normalisation();
  static const int kVolumeNormalisationFieldNumber = 2;
  inline bool volume_normalisation() const;
  inline void set_volume_normalisation(bool value);
  
  // @@protoc_insertion_point(class_scope:pb.spotify.PlaybackSettings)
 private:
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_volume_normalisation();
  inline void clear_has_volume_normalisation();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int bitrate_;
  bool volume_normalisation_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_spotifymessages_2eproto();
  friend void protobuf_AssignDesc_spotifymessages_2eproto();
  friend void protobuf_ShutdownFile_spotifymessages_2eproto();
  
  void InitAsDefaultInstance();
  static PlaybackSettings* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();
  
  Message(const Message& from);
  
  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();
  
  void Swap(Message* other);
  
  // implements Message ----------------------------------------------
  
  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 18;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 18;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional .pb.spotify.LoginRequest login_request = 1;
  inline bool has_login_request() const;
  inline void clear_login_request();
  static const int kLoginRequestFieldNumber = 1;
  inline const ::pb::spotify::LoginRequest& login_request() const;
  inline ::pb::spotify::LoginRequest* mutable_login_request();
  inline ::pb::spotify::LoginRequest* release_login_request();
  
  // optional .pb.spotify.LoginResponse login_response = 2;
  inline bool has_login_response() const;
  inline void clear_login_response();
  static const int kLoginResponseFieldNumber = 2;
  inline const ::pb::spotify::LoginResponse& login_response() const;
  inline ::pb::spotify::LoginResponse* mutable_login_response();
  inline ::pb::spotify::LoginResponse* release_login_response();
  
  // optional .pb.spotify.Playlists playlists_updated = 3;
  inline bool has_playlists_updated() const;
  inline void clear_playlists_updated();
  static const int kPlaylistsUpdatedFieldNumber = 3;
  inline const ::pb::spotify::Playlists& playlists_updated() const;
  inline ::pb::spotify::Playlists* mutable_playlists_updated();
  inline ::pb::spotify::Playlists* release_playlists_updated();
  
  // optional .pb.spotify.LoadPlaylistRequest load_playlist_request = 4;
  inline bool has_load_playlist_request() const;
  inline void clear_load_playlist_request();
  static const int kLoadPlaylistRequestFieldNumber = 4;
  inline const ::pb::spotify::LoadPlaylistRequest& load_playlist_request() const;
  inline ::pb::spotify::LoadPlaylistRequest* mutable_load_playlist_request();
  inline ::pb::spotify::LoadPlaylistRequest* release_load_playlist_request();
  
  // optional .pb.spotify.LoadPlaylistResponse load_playlist_response = 5;
  inline bool has_load_playlist_response() const;
  inline void clear_load_playlist_response();
  static const int kLoadPlaylistResponseFieldNumber = 5;
  inline const ::pb::spotify::LoadPlaylistResponse& load_playlist_response() const;
  inline ::pb::spotify::LoadPlaylistResponse* mutable_load_playlist_response();
  inline ::pb::spotify::LoadPlaylistResponse* release_load_playlist_response();
  
  // optional .pb.spotify.PlaybackRequest playback_request = 6;
  inline bool has_playback_request() const;
  inline void clear_playback_request();
  static const int kPlaybackRequestFieldNumber = 6;
  inline const ::pb::spotify::PlaybackRequest& playback_request() const;
  inline ::pb::spotify::PlaybackRequest* mutable_playback_request();
  inline ::pb::spotify::PlaybackRequest* release_playback_request();
  
  // optional .pb.spotify.PlaybackError playback_error = 7;
  inline bool has_playback_error() const;
  inline void clear_playback_error();
  static const int kPlaybackErrorFieldNumber = 7;
  inline const ::pb::spotify::PlaybackError& playback_error() const;
  inline ::pb::spotify::PlaybackError* mutable_playback_error();
  inline ::pb::spotify::PlaybackError* release_playback_error();
  
  // optional .pb.spotify.SearchRequest search_request = 8;
  inline bool has_search_request() const;
  inline void clear_search_request();
  static const int kSearchRequestFieldNumber = 8;
  inline const ::pb::spotify::SearchRequest& search_request() const;
  inline ::pb::spotify::SearchRequest* mutable_search_request();
  inline ::pb::spotify::SearchRequest* release_search_request();
  
  // optional .pb.spotify.SearchResponse search_response = 9;
  inline bool has_search_response() const;
  inline void clear_search_response();
  static const int kSearchResponseFieldNumber = 9;
  inline const ::pb::spotify::SearchResponse& search_response() const;
  inline ::pb::spotify::SearchResponse* mutable_search_response();
  inline ::pb::spotify::SearchResponse* release_search_response();
  
  // optional .pb.spotify.ImageRequest image_request = 10;
  inline bool has_image_request() const;
  inline void clear_image_request();
  static const int kImageRequestFieldNumber = 10;
  inline const ::pb::spotify::ImageRequest& image_request() const;
  inline ::pb::spotify::ImageRequest* mutable_image_request();
  inline ::pb::spotify::ImageRequest* release_image_request();
  
  // optional .pb.spotify.ImageResponse image_response = 11;
  inline bool has_image_response() const;
  inline void clear_image_response();
  static const int kImageResponseFieldNumber = 11;
  inline const ::pb::spotify::ImageResponse& image_response() const;
  inline ::pb::spotify::ImageResponse* mutable_image_response();
  inline ::pb::spotify::ImageResponse* release_image_response();
  
  // optional .pb.spotify.SyncPlaylistRequest sync_playlist_request = 12;
  inline bool has_sync_playlist_request() const;
  inline void clear_sync_playlist_request();
  static const int kSyncPlaylistRequestFieldNumber = 12;
  inline const ::pb::spotify::SyncPlaylistRequest& sync_playlist_request() const;
  inline ::pb::spotify::SyncPlaylistRequest* mutable_sync_playlist_request();
  inline ::pb::spotify::SyncPlaylistRequest* release_sync_playlist_request();
  
  // optional .pb.spotify.SyncPlaylistProgress sync_playlist_progress = 13;
  inline bool has_sync_playlist_progress() const;
  inline void clear_sync_playlist_progress();
  static const int kSyncPlaylistProgressFieldNumber = 13;
  inline const ::pb::spotify::SyncPlaylistProgress& sync_playlist_progress() const;
  inline ::pb::spotify::SyncPlaylistProgress* mutable_sync_playlist_progress();
  inline ::pb::spotify::SyncPlaylistProgress* release_sync_playlist_progress();
  
  // optional .pb.spotify.BrowseAlbumRequest browse_album_request = 14;
  inline bool has_browse_album_request() const;
  inline void clear_browse_album_request();
  static const int kBrowseAlbumRequestFieldNumber = 14;
  inline const ::pb::spotify::BrowseAlbumRequest& browse_album_request() const;
  inline ::pb::spotify::BrowseAlbumRequest* mutable_browse_album_request();
  inline ::pb::spotify::BrowseAlbumRequest* release_browse_album_request();
  
  // optional .pb.spotify.BrowseAlbumResponse browse_album_response = 15;
  inline bool has_browse_album_response() const;
  inline void clear_browse_album_response();
  static const int kBrowseAlbumResponseFieldNumber = 15;
  inline const ::pb::spotify::BrowseAlbumResponse& browse_album_response() const;
  inline ::pb::spotify::BrowseAlbumResponse* mutable_browse_album_response();
  inline ::pb::spotify::BrowseAlbumResponse* release_browse_album_response();
  
  // optional .pb.spotify.SeekRequest seek_request = 16;
  inline bool has_seek_request() const;
  inline void clear_seek_request();
  static const int kSeekRequestFieldNumber = 16;
  inline const ::pb::spotify::SeekRequest& seek_request() const;
  inline ::pb::spotify::SeekRequest* mutable_seek_request();
  inline ::pb::spotify::SeekRequest* release_seek_request();
  
  // optional .pb.spotify.PlaybackSettings set_playback_settings_request = 17;
  inline bool has_set_playback_settings_request() const;
  inline void clear_set_playback_settings_request();
  static const int kSetPlaybackSettingsRequestFieldNumber = 17;
  inline const ::pb::spotify::PlaybackSettings& set_playback_settings_request() const;
  inline ::pb::spotify::PlaybackSettings* mutable_set_playback_settings_request();
  inline ::pb::spotify::PlaybackSettings* release_set_playback_settings_request();
  
  // optional .pb.spotify.BrowseToplistRequest browse_toplist_request = 19;
  inline bool has_browse_toplist_request() const;
  inline void clear_browse_toplist_request();
  static const int kBrowseToplistRequestFieldNumber = 19;
  inline const ::pb::spotify::BrowseToplistRequest& browse_toplist_request() const;
  inline ::pb::spotify::BrowseToplistRequest* mutable_browse_toplist_request();
  inline ::pb::spotify::BrowseToplistRequest* release_browse_toplist_request();
  
  // optional .pb.spotify.BrowseToplistResponse browse_toplist_response = 20;
  inline bool has_browse_toplist_response() const;
  inline void clear_browse_toplist_response();
  static const int kBrowseToplistResponseFieldNumber = 20;
  inline const ::pb::spotify::BrowseToplistResponse& browse_toplist_response() const;
  inline ::pb::spotify::BrowseToplistResponse* mutable_browse_toplist_response();
  inline ::pb::spotify::BrowseToplistResponse* release_browse_toplist_response();
  
  // @@protoc_insertion_point(class_scope:pb.spotify.Message)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_login_request();
  inline void clear_has_login_request();
  inline void set_has_login_response();
  inline void clear_has_login_response();
  inline void set_has_playlists_updated();
  inline void clear_has_playlists_updated();
  inline void set_has_load_playlist_request();
  inline void clear_has_load_playlist_request();
  inline void set_has_load_playlist_response();
  inline void clear_has_load_playlist_response();
  inline void set_has_playback_request();
  inline void clear_has_playback_request();
  inline void set_has_playback_error();
  inline void clear_has_playback_error();
  inline void set_has_search_request();
  inline void clear_has_search_request();
  inline void set_has_search_response();
  inline void clear_has_search_response();
  inline void set_has_image_request();
  inline void clear_has_image_request();
  inline void set_has_image_response();
  inline void clear_has_image_response();
  inline void set_has_sync_playlist_request();
  inline void clear_has_sync_playlist_request();
  inline void set_has_sync_playlist_progress();
  inline void clear_has_sync_playlist_progress();
  inline void set_has_browse_album_request();
  inline void clear_has_browse_album_request();
  inline void set_has_browse_album_response();
  inline void clear_has_browse_album_response();
  inline void set_has_seek_request();
  inline void clear_has_seek_request();
  inline void set_has_set_playback_settings_request();
  inline void clear_has_set_playback_settings_request();
  inline void set_has_browse_toplist_request();
  inline void clear_has_browse_toplist_request();
  inline void set_has_browse_toplist_response();
  inline void clear_has_browse_toplist_response();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::pb::spotify::LoginRequest* login_request_;
  ::pb::spotify::LoginResponse* login_response_;
  ::pb::spotify::Playlists* playlists_updated_;
  ::pb::spotify::LoadPlaylistRequest* load_playlist_request_;
  ::pb::spotify::LoadPlaylistResponse* load_playlist_response_;
  ::pb::spotify::PlaybackRequest* playback_request_;
  ::pb::spotify::PlaybackError* playback_error_;
  ::pb::spotify::SearchRequest* search_request_;
  ::pb::spotify::SearchResponse* search_response_;
  ::pb::spotify::ImageRequest* image_request_;
  ::pb::spotify::ImageResponse* image_response_;
  ::pb::spotify::SyncPlaylistRequest* sync_playlist_request_;
  ::pb::spotify::SyncPlaylistProgress* sync_playlist_progress_;
  ::pb::spotify::BrowseAlbumRequest* browse_album_request_;
  ::pb::spotify::BrowseAlbumResponse* browse_album_response_;
  ::pb::spotify::SeekRequest* seek_request_;
  ::pb::spotify::PlaybackSettings* set_playback_settings_request_;
  ::pb::spotify::BrowseToplistRequest* browse_toplist_request_;
  ::pb::spotify::BrowseToplistResponse* browse_toplist_response_;
  ::google::protobuf::int32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(20 + 31) / 32];
  
  friend void  protobuf_AddDesc_spotifymessages_2eproto();
  friend void protobuf_AssignDesc_spotifymessages_2eproto();
  friend void protobuf_ShutdownFile_spotifymessages_2eproto();
  
  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginRequest

// required string username = 1;
inline bool LoginRequest::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& LoginRequest::username() const {
  return *username_;
}
inline void LoginRequest::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void LoginRequest::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void LoginRequest::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* LoginRequest::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string password = 2;
inline bool LoginRequest::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& LoginRequest::password() const {
  return *password_;
}
inline void LoginRequest::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequest::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequest::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* LoginRequest::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .pb.spotify.PlaybackSettings playback_settings = 3;
inline bool LoginRequest::has_playback_settings() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRequest::set_has_playback_settings() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginRequest::clear_has_playback_settings() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginRequest::clear_playback_settings() {
  if (playback_settings_ != NULL) playback_settings_->::pb::spotify::PlaybackSettings::Clear();
  clear_has_playback_settings();
}
inline const ::pb::spotify::PlaybackSettings& LoginRequest::playback_settings() const {
  return playback_settings_ != NULL ? *playback_settings_ : *default_instance_->playback_settings_;
}
inline ::pb::spotify::PlaybackSettings* LoginRequest::mutable_playback_settings() {
  set_has_playback_settings();
  if (playback_settings_ == NULL) playback_settings_ = new ::pb::spotify::PlaybackSettings;
  return playback_settings_;
}
inline ::pb::spotify::PlaybackSettings* LoginRequest::release_playback_settings() {
  clear_has_playback_settings();
  ::pb::spotify::PlaybackSettings* temp = playback_settings_;
  playback_settings_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// LoginResponse

// required bool success = 1;
inline bool LoginResponse::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResponse::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResponse::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool LoginResponse::success() const {
  return success_;
}
inline void LoginResponse::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// required string error = 2;
inline bool LoginResponse::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResponse::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResponse::clear_error() {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& LoginResponse::error() const {
  return *error_;
}
inline void LoginResponse::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void LoginResponse::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void LoginResponse::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  return error_;
}
inline ::std::string* LoginResponse::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .pb.spotify.LoginResponse.Error error_code = 3 [default = Other];
inline bool LoginResponse::has_error_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginResponse::set_has_error_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginResponse::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginResponse::clear_error_code() {
  error_code_ = 4;
  clear_has_error_code();
}
inline ::pb::spotify::LoginResponse_Error LoginResponse::error_code() const {
  return static_cast< ::pb::spotify::LoginResponse_Error >(error_code_);
}
inline void LoginResponse::set_error_code(::pb::spotify::LoginResponse_Error value) {
  GOOGLE_DCHECK(::pb::spotify::LoginResponse_Error_IsValid(value));
  set_has_error_code();
  error_code_ = value;
}

// -------------------------------------------------------------------

// Playlists_Playlist

// required int32 index = 1;
inline bool Playlists_Playlist::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Playlists_Playlist::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Playlists_Playlist::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Playlists_Playlist::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 Playlists_Playlist::index() const {
  return index_;
}
inline void Playlists_Playlist::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// required string name = 2;
inline bool Playlists_Playlist::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Playlists_Playlist::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Playlists_Playlist::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Playlists_Playlist::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Playlists_Playlist::name() const {
  return *name_;
}
inline void Playlists_Playlist::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Playlists_Playlist::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Playlists_Playlist::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Playlists_Playlist::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Playlists_Playlist::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool is_offline = 3;
inline bool Playlists_Playlist::has_is_offline() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Playlists_Playlist::set_has_is_offline() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Playlists_Playlist::clear_has_is_offline() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Playlists_Playlist::clear_is_offline() {
  is_offline_ = false;
  clear_has_is_offline();
}
inline bool Playlists_Playlist::is_offline() const {
  return is_offline_;
}
inline void Playlists_Playlist::set_is_offline(bool value) {
  set_has_is_offline();
  is_offline_ = value;
}

// optional int32 download_progress = 4;
inline bool Playlists_Playlist::has_download_progress() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Playlists_Playlist::set_has_download_progress() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Playlists_Playlist::clear_has_download_progress() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Playlists_Playlist::clear_download_progress() {
  download_progress_ = 0;
  clear_has_download_progress();
}
inline ::google::protobuf::int32 Playlists_Playlist::download_progress() const {
  return download_progress_;
}
inline void Playlists_Playlist::set_download_progress(::google::protobuf::int32 value) {
  set_has_download_progress();
  download_progress_ = value;
}

// -------------------------------------------------------------------

// Playlists

// repeated .pb.spotify.Playlists.Playlist playlist = 1;
inline int Playlists::playlist_size() const {
  return playlist_.size();
}
inline void Playlists::clear_playlist() {
  playlist_.Clear();
}
inline const ::pb::spotify::Playlists_Playlist& Playlists::playlist(int index) const {
  return playlist_.Get(index);
}
inline ::pb::spotify::Playlists_Playlist* Playlists::mutable_playlist(int index) {
  return playlist_.Mutable(index);
}
inline ::pb::spotify::Playlists_Playlist* Playlists::add_playlist() {
  return playlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::spotify::Playlists_Playlist >&
Playlists::playlist() const {
  return playlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::spotify::Playlists_Playlist >*
Playlists::mutable_playlist() {
  return &playlist_;
}

// -------------------------------------------------------------------

// Track

// required bool starred = 1;
inline bool Track::has_starred() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Track::set_has_starred() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Track::clear_has_starred() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Track::clear_starred() {
  starred_ = false;
  clear_has_starred();
}
inline bool Track::starred() const {
  return starred_;
}
inline void Track::set_starred(bool value) {
  set_has_starred();
  starred_ = value;
}

// required string title = 2;
inline bool Track::has_title() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Track::set_has_title() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Track::clear_has_title() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Track::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& Track::title() const {
  return *title_;
}
inline void Track::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void Track::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void Track::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Track::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* Track::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string artist = 3;
inline int Track::artist_size() const {
  return artist_.size();
}
inline void Track::clear_artist() {
  artist_.Clear();
}
inline const ::std::string& Track::artist(int index) const {
  return artist_.Get(index);
}
inline ::std::string* Track::mutable_artist(int index) {
  return artist_.Mutable(index);
}
inline void Track::set_artist(int index, const ::std::string& value) {
  artist_.Mutable(index)->assign(value);
}
inline void Track::set_artist(int index, const char* value) {
  artist_.Mutable(index)->assign(value);
}
inline void Track::set_artist(int index, const char* value, size_t size) {
  artist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Track::add_artist() {
  return artist_.Add();
}
inline void Track::add_artist(const ::std::string& value) {
  artist_.Add()->assign(value);
}
inline void Track::add_artist(const char* value) {
  artist_.Add()->assign(value);
}
inline void Track::add_artist(const char* value, size_t size) {
  artist_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Track::artist() const {
  return artist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Track::mutable_artist() {
  return &artist_;
}

// required string album = 4;
inline bool Track::has_album() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Track::set_has_album() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Track::clear_has_album() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Track::clear_album() {
  if (album_ != &::google::protobuf::internal::kEmptyString) {
    album_->clear();
  }
  clear_has_album();
}
inline const ::std::string& Track::album() const {
  return *album_;
}
inline void Track::set_album(const ::std::string& value) {
  set_has_album();
  if (album_ == &::google::protobuf::internal::kEmptyString) {
    album_ = new ::std::string;
  }
  album_->assign(value);
}
inline void Track::set_album(const char* value) {
  set_has_album();
  if (album_ == &::google::protobuf::internal::kEmptyString) {
    album_ = new ::std::string;
  }
  album_->assign(value);
}
inline void Track::set_album(const char* value, size_t size) {
  set_has_album();
  if (album_ == &::google::protobuf::internal::kEmptyString) {
    album_ = new ::std::string;
  }
  album_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Track::mutable_album() {
  set_has_album();
  if (album_ == &::google::protobuf::internal::kEmptyString) {
    album_ = new ::std::string;
  }
  return album_;
}
inline ::std::string* Track::release_album() {
  clear_has_album();
  if (album_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = album_;
    album_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 duration_msec = 5;
inline bool Track::has_duration_msec() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Track::set_has_duration_msec() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Track::clear_has_duration_msec() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Track::clear_duration_msec() {
  duration_msec_ = 0;
  clear_has_duration_msec();
}
inline ::google::protobuf::int32 Track::duration_msec() const {
  return duration_msec_;
}
inline void Track::set_duration_msec(::google::protobuf::int32 value) {
  set_has_duration_msec();
  duration_msec_ = value;
}

// required int32 popularity = 6;
inline bool Track::has_popularity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Track::set_has_popularity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Track::clear_has_popularity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Track::clear_popularity() {
  popularity_ = 0;
  clear_has_popularity();
}
inline ::google::protobuf::int32 Track::popularity() const {
  return popularity_;
}
inline void Track::set_popularity(::google::protobuf::int32 value) {
  set_has_popularity();
  popularity_ = value;
}

// required int32 disc = 7;
inline bool Track::has_disc() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Track::set_has_disc() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Track::clear_has_disc() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Track::clear_disc() {
  disc_ = 0;
  clear_has_disc();
}
inline ::google::protobuf::int32 Track::disc() const {
  return disc_;
}
inline void Track::set_disc(::google::protobuf::int32 value) {
  set_has_disc();
  disc_ = value;
}

// required int32 track = 8;
inline bool Track::has_track() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Track::set_has_track() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Track::clear_has_track() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Track::clear_track() {
  track_ = 0;
  clear_has_track();
}
inline ::google::protobuf::int32 Track::track() const {
  return track_;
}
inline void Track::set_track(::google::protobuf::int32 value) {
  set_has_track();
  track_ = value;
}

// required int32 year = 9;
inline bool Track::has_year() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Track::set_has_year() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Track::clear_has_year() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Track::clear_year() {
  year_ = 0;
  clear_has_year();
}
inline ::google::protobuf::int32 Track::year() const {
  return year_;
}
inline void Track::set_year(::google::protobuf::int32 value) {
  set_has_year();
  year_ = value;
}

// required string uri = 10;
inline bool Track::has_uri() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Track::set_has_uri() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Track::clear_has_uri() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Track::clear_uri() {
  if (uri_ != &::google::protobuf::internal::kEmptyString) {
    uri_->clear();
  }
  clear_has_uri();
}
inline const ::std::string& Track::uri() const {
  return *uri_;
}
inline void Track::set_uri(const ::std::string& value) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::kEmptyString) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
}
inline void Track::set_uri(const char* value) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::kEmptyString) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
}
inline void Track::set_uri(const char* value, size_t size) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::kEmptyString) {
    uri_ = new ::std::string;
  }
  uri_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Track::mutable_uri() {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::kEmptyString) {
    uri_ = new ::std::string;
  }
  return uri_;
}
inline ::std::string* Track::release_uri() {
  clear_has_uri();
  if (uri_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uri_;
    uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string album_art_id = 11;
inline bool Track::has_album_art_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Track::set_has_album_art_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Track::clear_has_album_art_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Track::clear_album_art_id() {
  if (album_art_id_ != &::google::protobuf::internal::kEmptyString) {
    album_art_id_->clear();
  }
  clear_has_album_art_id();
}
inline const ::std::string& Track::album_art_id() const {
  return *album_art_id_;
}
inline void Track::set_album_art_id(const ::std::string& value) {
  set_has_album_art_id();
  if (album_art_id_ == &::google::protobuf::internal::kEmptyString) {
    album_art_id_ = new ::std::string;
  }
  album_art_id_->assign(value);
}
inline void Track::set_album_art_id(const char* value) {
  set_has_album_art_id();
  if (album_art_id_ == &::google::protobuf::internal::kEmptyString) {
    album_art_id_ = new ::std::string;
  }
  album_art_id_->assign(value);
}
inline void Track::set_album_art_id(const char* value, size_t size) {
  set_has_album_art_id();
  if (album_art_id_ == &::google::protobuf::internal::kEmptyString) {
    album_art_id_ = new ::std::string;
  }
  album_art_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Track::mutable_album_art_id() {
  set_has_album_art_id();
  if (album_art_id_ == &::google::protobuf::internal::kEmptyString) {
    album_art_id_ = new ::std::string;
  }
  return album_art_id_;
}
inline ::std::string* Track::release_album_art_id() {
  clear_has_album_art_id();
  if (album_art_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = album_art_id_;
    album_art_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Album

// required .pb.spotify.Track metadata = 1;
inline bool Album::has_metadata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Album::set_has_metadata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Album::clear_has_metadata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Album::clear_metadata() {
  if (metadata_ != NULL) metadata_->::pb::spotify::Track::Clear();
  clear_has_metadata();
}
inline const ::pb::spotify::Track& Album::metadata() const {
  return metadata_ != NULL ? *metadata_ : *default_instance_->metadata_;
}
inline ::pb::spotify::Track* Album::mutable_metadata() {
  set_has_metadata();
  if (metadata_ == NULL) metadata_ = new ::pb::spotify::Track;
  return metadata_;
}
inline ::pb::spotify::Track* Album::release_metadata() {
  clear_has_metadata();
  ::pb::spotify::Track* temp = metadata_;
  metadata_ = NULL;
  return temp;
}

// repeated .pb.spotify.Track track = 2;
inline int Album::track_size() const {
  return track_.size();
}
inline void Album::clear_track() {
  track_.Clear();
}
inline const ::pb::spotify::Track& Album::track(int index) const {
  return track_.Get(index);
}
inline ::pb::spotify::Track* Album::mutable_track(int index) {
  return track_.Mutable(index);
}
inline ::pb::spotify::Track* Album::add_track() {
  return track_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::spotify::Track >&
Album::track() const {
  return track_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::spotify::Track >*
Album::mutable_track() {
  return &track_;
}

// -------------------------------------------------------------------

// LoadPlaylistRequest

// required .pb.spotify.PlaylistType type = 1;
inline bool LoadPlaylistRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadPlaylistRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadPlaylistRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadPlaylistRequest::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline pb::spotify::PlaylistType LoadPlaylistRequest::type() const {
  return static_cast< pb::spotify::PlaylistType >(type_);
}
inline void LoadPlaylistRequest::set_type(pb::spotify::PlaylistType value) {
  GOOGLE_DCHECK(pb::spotify::PlaylistType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 user_playlist_index = 2;
inline bool LoadPlaylistRequest::has_user_playlist_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoadPlaylistRequest::set_has_user_playlist_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoadPlaylistRequest::clear_has_user_playlist_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoadPlaylistRequest::clear_user_playlist_index() {
  user_playlist_index_ = 0;
  clear_has_user_playlist_index();
}
inline ::google::protobuf::int32 LoadPlaylistRequest::user_playlist_index() const {
  return user_playlist_index_;
}
inline void LoadPlaylistRequest::set_user_playlist_index(::google::protobuf::int32 value) {
  set_has_user_playlist_index();
  user_playlist_index_ = value;
}

// -------------------------------------------------------------------

// LoadPlaylistResponse

// required .pb.spotify.LoadPlaylistRequest request = 1;
inline bool LoadPlaylistResponse::has_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadPlaylistResponse::set_has_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadPlaylistResponse::clear_has_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadPlaylistResponse::clear_request() {
  if (request_ != NULL) request_->::pb::spotify::LoadPlaylistRequest::Clear();
  clear_has_request();
}
inline const ::pb::spotify::LoadPlaylistRequest& LoadPlaylistResponse::request() const {
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::pb::spotify::LoadPlaylistRequest* LoadPlaylistResponse::mutable_request() {
  set_has_request();
  if (request_ == NULL) request_ = new ::pb::spotify::LoadPlaylistRequest;
  return request_;
}
inline ::pb::spotify::LoadPlaylistRequest* LoadPlaylistResponse::release_request() {
  clear_has_request();
  ::pb::spotify::LoadPlaylistRequest* temp = request_;
  request_ = NULL;
  return temp;
}

// repeated .pb.spotify.Track track = 2;
inline int LoadPlaylistResponse::track_size() const {
  return track_.size();
}
inline void LoadPlaylistResponse::clear_track() {
  track_.Clear();
}
inline const ::pb::spotify::Track& LoadPlaylistResponse::track(int index) const {
  return track_.Get(index);
}
inline ::pb::spotify::Track* LoadPlaylistResponse::mutable_track(int index) {
  return track_.Mutable(index);
}
inline ::pb::spotify::Track* LoadPlaylistResponse::add_track() {
  return track_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::spotify::Track >&
LoadPlaylistResponse::track() const {
  return track_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::spotify::Track >*
LoadPlaylistResponse::mutable_track() {
  return &track_;
}

// -------------------------------------------------------------------

// SyncPlaylistRequest

// required .pb.spotify.LoadPlaylistRequest request = 1;
inline bool SyncPlaylistRequest::has_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncPlaylistRequest::set_has_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncPlaylistRequest::clear_has_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncPlaylistRequest::clear_request() {
  if (request_ != NULL) request_->::pb::spotify::LoadPlaylistRequest::Clear();
  clear_has_request();
}
inline const ::pb::spotify::LoadPlaylistRequest& SyncPlaylistRequest::request() const {
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::pb::spotify::LoadPlaylistRequest* SyncPlaylistRequest::mutable_request() {
  set_has_request();
  if (request_ == NULL) request_ = new ::pb::spotify::LoadPlaylistRequest;
  return request_;
}
inline ::pb::spotify::LoadPlaylistRequest* SyncPlaylistRequest::release_request() {
  clear_has_request();
  ::pb::spotify::LoadPlaylistRequest* temp = request_;
  request_ = NULL;
  return temp;
}

// required bool offline_sync = 2;
inline bool SyncPlaylistRequest::has_offline_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncPlaylistRequest::set_has_offline_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncPlaylistRequest::clear_has_offline_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncPlaylistRequest::clear_offline_sync() {
  offline_sync_ = false;
  clear_has_offline_sync();
}
inline bool SyncPlaylistRequest::offline_sync() const {
  return offline_sync_;
}
inline void SyncPlaylistRequest::set_offline_sync(bool value) {
  set_has_offline_sync();
  offline_sync_ = value;
}

// -------------------------------------------------------------------

// SyncPlaylistProgress

// required .pb.spotify.LoadPlaylistRequest request = 1;
inline bool SyncPlaylistProgress::has_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncPlaylistProgress::set_has_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncPlaylistProgress::clear_has_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncPlaylistProgress::clear_request() {
  if (request_ != NULL) request_->::pb::spotify::LoadPlaylistRequest::Clear();
  clear_has_request();
}
inline const ::pb::spotify::LoadPlaylistRequest& SyncPlaylistProgress::request() const {
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::pb::spotify::LoadPlaylistRequest* SyncPlaylistProgress::mutable_request() {
  set_has_request();
  if (request_ == NULL) request_ = new ::pb::spotify::LoadPlaylistRequest;
  return request_;
}
inline ::pb::spotify::LoadPlaylistRequest* SyncPlaylistProgress::release_request() {
  clear_has_request();
  ::pb::spotify::LoadPlaylistRequest* temp = request_;
  request_ = NULL;
  return temp;
}

// required int32 sync_progress = 2;
inline bool SyncPlaylistProgress::has_sync_progress() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncPlaylistProgress::set_has_sync_progress() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncPlaylistProgress::clear_has_sync_progress() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncPlaylistProgress::clear_sync_progress() {
  sync_progress_ = 0;
  clear_has_sync_progress();
}
inline ::google::protobuf::int32 SyncPlaylistProgress::sync_progress() const {
  return sync_progress_;
}
inline void SyncPlaylistProgress::set_sync_progress(::google::protobuf::int32 value) {
  set_has_sync_progress();
  sync_progress_ = value;
}

// -------------------------------------------------------------------

// PlaybackRequest

// required string track_uri = 1;
inline bool PlaybackRequest::has_track_uri() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlaybackRequest::set_has_track_uri() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlaybackRequest::clear_has_track_uri() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlaybackRequest::clear_track_uri() {
  if (track_uri_ != &::google::protobuf::internal::kEmptyString) {
    track_uri_->clear();
  }
  clear_has_track_uri();
}
inline const ::std::string& PlaybackRequest::track_uri() const {
  return *track_uri_;
}
inline void PlaybackRequest::set_track_uri(const ::std::string& value) {
  set_has_track_uri();
  if (track_uri_ == &::google::protobuf::internal::kEmptyString) {
    track_uri_ = new ::std::string;
  }
  track_uri_->assign(value);
}
inline void PlaybackRequest::set_track_uri(const char* value) {
  set_has_track_uri();
  if (track_uri_ == &::google::protobuf::internal::kEmptyString) {
    track_uri_ = new ::std::string;
  }
  track_uri_->assign(value);
}
inline void PlaybackRequest::set_track_uri(const char* value, size_t size) {
  set_has_track_uri();
  if (track_uri_ == &::google::protobuf::internal::kEmptyString) {
    track_uri_ = new ::std::string;
  }
  track_uri_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlaybackRequest::mutable_track_uri() {
  set_has_track_uri();
  if (track_uri_ == &::google::protobuf::internal::kEmptyString) {
    track_uri_ = new ::std::string;
  }
  return track_uri_;
}
inline ::std::string* PlaybackRequest::release_track_uri() {
  clear_has_track_uri();
  if (track_uri_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = track_uri_;
    track_uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 media_port = 2;
inline bool PlaybackRequest::has_media_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlaybackRequest::set_has_media_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlaybackRequest::clear_has_media_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlaybackRequest::clear_media_port() {
  media_port_ = 0;
  clear_has_media_port();
}
inline ::google::protobuf::int32 PlaybackRequest::media_port() const {
  return media_port_;
}
inline void PlaybackRequest::set_media_port(::google::protobuf::int32 value) {
  set_has_media_port();
  media_port_ = value;
}

// -------------------------------------------------------------------

// PlaybackError

// required string error = 1;
inline bool PlaybackError::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlaybackError::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlaybackError::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlaybackError::clear_error() {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& PlaybackError::error() const {
  return *error_;
}
inline void PlaybackError::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void PlaybackError::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void PlaybackError::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlaybackError::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  return error_;
}
inline ::std::string* PlaybackError::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SearchRequest

// required string query = 1;
inline bool SearchRequest::has_query() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchRequest::set_has_query() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchRequest::clear_has_query() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchRequest::clear_query() {
  if (query_ != &::google::protobuf::internal::kEmptyString) {
    query_->clear();
  }
  clear_has_query();
}
inline const ::std::string& SearchRequest::query() const {
  return *query_;
}
inline void SearchRequest::set_query(const ::std::string& value) {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  query_->assign(value);
}
inline void SearchRequest::set_query(const char* value) {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  query_->assign(value);
}
inline void SearchRequest::set_query(const char* value, size_t size) {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  query_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchRequest::mutable_query() {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  return query_;
}
inline ::std::string* SearchRequest::release_query() {
  clear_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = query_;
    query_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 limit = 2 [default = 250];
inline bool SearchRequest::has_limit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchRequest::set_has_limit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SearchRequest::clear_has_limit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SearchRequest::clear_limit() {
  limit_ = 250;
  clear_has_limit();
}
inline ::google::protobuf::int32 SearchRequest::limit() const {
  return limit_;
}
inline void SearchRequest::set_limit(::google::protobuf::int32 value) {
  set_has_limit();
  limit_ = value;
}

// optional int32 limit_album = 3 [default = 0];
inline bool SearchRequest::has_limit_album() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SearchRequest::set_has_limit_album() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SearchRequest::clear_has_limit_album() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SearchRequest::clear_limit_album() {
  limit_album_ = 0;
  clear_has_limit_album();
}
inline ::google::protobuf::int32 SearchRequest::limit_album() const {
  return limit_album_;
}
inline void SearchRequest::set_limit_album(::google::protobuf::int32 value) {
  set_has_limit_album();
  limit_album_ = value;
}

// -------------------------------------------------------------------

// SearchResponse

// required .pb.spotify.SearchRequest request = 1;
inline bool SearchResponse::has_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchResponse::set_has_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchResponse::clear_has_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchResponse::clear_request() {
  if (request_ != NULL) request_->::pb::spotify::SearchRequest::Clear();
  clear_has_request();
}
inline const ::pb::spotify::SearchRequest& SearchResponse::request() const {
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::pb::spotify::SearchRequest* SearchResponse::mutable_request() {
  set_has_request();
  if (request_ == NULL) request_ = new ::pb::spotify::SearchRequest;
  return request_;
}
inline ::pb::spotify::SearchRequest* SearchResponse::release_request() {
  clear_has_request();
  ::pb::spotify::SearchRequest* temp = request_;
  request_ = NULL;
  return temp;
}

// repeated .pb.spotify.Track result = 2;
inline int SearchResponse::result_size() const {
  return result_.size();
}
inline void SearchResponse::clear_result() {
  result_.Clear();
}
inline const ::pb::spotify::Track& SearchResponse::result(int index) const {
  return result_.Get(index);
}
inline ::pb::spotify::Track* SearchResponse::mutable_result(int index) {
  return result_.Mutable(index);
}
inline ::pb::spotify::Track* SearchResponse::add_result() {
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::spotify::Track >&
SearchResponse::result() const {
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::spotify::Track >*
SearchResponse::mutable_result() {
  return &result_;
}

// optional int32 total_tracks = 3;
inline bool SearchResponse::has_total_tracks() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SearchResponse::set_has_total_tracks() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SearchResponse::clear_has_total_tracks() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SearchResponse::clear_total_tracks() {
  total_tracks_ = 0;
  clear_has_total_tracks();
}
inline ::google::protobuf::int32 SearchResponse::total_tracks() const {
  return total_tracks_;
}
inline void SearchResponse::set_total_tracks(::google::protobuf::int32 value) {
  set_has_total_tracks();
  total_tracks_ = value;
}

// optional string did_you_mean = 4;
inline bool SearchResponse::has_did_you_mean() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SearchResponse::set_has_did_you_mean() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SearchResponse::clear_has_did_you_mean() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SearchResponse::clear_did_you_mean() {
  if (did_you_mean_ != &::google::protobuf::internal::kEmptyString) {
    did_you_mean_->clear();
  }
  clear_has_did_you_mean();
}
inline const ::std::string& SearchResponse::did_you_mean() const {
  return *did_you_mean_;
}
inline void SearchResponse::set_did_you_mean(const ::std::string& value) {
  set_has_did_you_mean();
  if (did_you_mean_ == &::google::protobuf::internal::kEmptyString) {
    did_you_mean_ = new ::std::string;
  }
  did_you_mean_->assign(value);
}
inline void SearchResponse::set_did_you_mean(const char* value) {
  set_has_did_you_mean();
  if (did_you_mean_ == &::google::protobuf::internal::kEmptyString) {
    did_you_mean_ = new ::std::string;
  }
  did_you_mean_->assign(value);
}
inline void SearchResponse::set_did_you_mean(const char* value, size_t size) {
  set_has_did_you_mean();
  if (did_you_mean_ == &::google::protobuf::internal::kEmptyString) {
    did_you_mean_ = new ::std::string;
  }
  did_you_mean_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchResponse::mutable_did_you_mean() {
  set_has_did_you_mean();
  if (did_you_mean_ == &::google::protobuf::internal::kEmptyString) {
    did_you_mean_ = new ::std::string;
  }
  return did_you_mean_;
}
inline ::std::string* SearchResponse::release_did_you_mean() {
  clear_has_did_you_mean();
  if (did_you_mean_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = did_you_mean_;
    did_you_mean_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string error = 5;
inline bool SearchResponse::has_error() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SearchResponse::set_has_error() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SearchResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SearchResponse::clear_error() {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& SearchResponse::error() const {
  return *error_;
}
inline void SearchResponse::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void SearchResponse::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void SearchResponse::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchResponse::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  return error_;
}
inline ::std::string* SearchResponse::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .pb.spotify.Album album = 7;
inline int SearchResponse::album_size() const {
  return album_.size();
}
inline void SearchResponse::clear_album() {
  album_.Clear();
}
inline const ::pb::spotify::Album& SearchResponse::album(int index) const {
  return album_.Get(index);
}
inline ::pb::spotify::Album* SearchResponse::mutable_album(int index) {
  return album_.Mutable(index);
}
inline ::pb::spotify::Album* SearchResponse::add_album() {
  return album_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::spotify::Album >&
SearchResponse::album() const {
  return album_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::spotify::Album >*
SearchResponse::mutable_album() {
  return &album_;
}

// -------------------------------------------------------------------

// ImageRequest

// required string id = 1;
inline bool ImageRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageRequest::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ImageRequest::id() const {
  return *id_;
}
inline void ImageRequest::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ImageRequest::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ImageRequest::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImageRequest::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ImageRequest::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ImageResponse

// required string id = 1;
inline bool ImageResponse::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageResponse::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageResponse::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ImageResponse::id() const {
  return *id_;
}
inline void ImageResponse::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ImageResponse::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ImageResponse::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImageResponse::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ImageResponse::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes data = 2;
inline bool ImageResponse::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageResponse::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageResponse::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageResponse::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ImageResponse::data() const {
  return *data_;
}
inline void ImageResponse::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ImageResponse::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ImageResponse::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImageResponse::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* ImageResponse::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BrowseAlbumRequest

// required string uri = 1;
inline bool BrowseAlbumRequest::has_uri() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BrowseAlbumRequest::set_has_uri() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BrowseAlbumRequest::clear_has_uri() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BrowseAlbumRequest::clear_uri() {
  if (uri_ != &::google::protobuf::internal::kEmptyString) {
    uri_->clear();
  }
  clear_has_uri();
}
inline const ::std::string& BrowseAlbumRequest::uri() const {
  return *uri_;
}
inline void BrowseAlbumRequest::set_uri(const ::std::string& value) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::kEmptyString) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
}
inline void BrowseAlbumRequest::set_uri(const char* value) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::kEmptyString) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
}
inline void BrowseAlbumRequest::set_uri(const char* value, size_t size) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::kEmptyString) {
    uri_ = new ::std::string;
  }
  uri_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BrowseAlbumRequest::mutable_uri() {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::kEmptyString) {
    uri_ = new ::std::string;
  }
  return uri_;
}
inline ::std::string* BrowseAlbumRequest::release_uri() {
  clear_has_uri();
  if (uri_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uri_;
    uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BrowseAlbumResponse

// required string uri = 1;
inline bool BrowseAlbumResponse::has_uri() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BrowseAlbumResponse::set_has_uri() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BrowseAlbumResponse::clear_has_uri() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BrowseAlbumResponse::clear_uri() {
  if (uri_ != &::google::protobuf::internal::kEmptyString) {
    uri_->clear();
  }
  clear_has_uri();
}
inline const ::std::string& BrowseAlbumResponse::uri() const {
  return *uri_;
}
inline void BrowseAlbumResponse::set_uri(const ::std::string& value) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::kEmptyString) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
}
inline void BrowseAlbumResponse::set_uri(const char* value) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::kEmptyString) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
}
inline void BrowseAlbumResponse::set_uri(const char* value, size_t size) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::kEmptyString) {
    uri_ = new ::std::string;
  }
  uri_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BrowseAlbumResponse::mutable_uri() {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::kEmptyString) {
    uri_ = new ::std::string;
  }
  return uri_;
}
inline ::std::string* BrowseAlbumResponse::release_uri() {
  clear_has_uri();
  if (uri_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uri_;
    uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .pb.spotify.Track track = 2;
inline int BrowseAlbumResponse::track_size() const {
  return track_.size();
}
inline void BrowseAlbumResponse::clear_track() {
  track_.Clear();
}
inline const ::pb::spotify::Track& BrowseAlbumResponse::track(int index) const {
  return track_.Get(index);
}
inline ::pb::spotify::Track* BrowseAlbumResponse::mutable_track(int index) {
  return track_.Mutable(index);
}
inline ::pb::spotify::Track* BrowseAlbumResponse::add_track() {
  return track_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::spotify::Track >&
BrowseAlbumResponse::track() const {
  return track_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::spotify::Track >*
BrowseAlbumResponse::mutable_track() {
  return &track_;
}

// -------------------------------------------------------------------

// BrowseToplistRequest

// required .pb.spotify.BrowseToplistRequest.ToplistType type = 1;
inline bool BrowseToplistRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BrowseToplistRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BrowseToplistRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BrowseToplistRequest::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::pb::spotify::BrowseToplistRequest_ToplistType BrowseToplistRequest::type() const {
  return static_cast< ::pb::spotify::BrowseToplistRequest_ToplistType >(type_);
}
inline void BrowseToplistRequest::set_type(::pb::spotify::BrowseToplistRequest_ToplistType value) {
  GOOGLE_DCHECK(::pb::spotify::BrowseToplistRequest_ToplistType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .pb.spotify.BrowseToplistRequest.Region region = 2 [default = Everywhere];
inline bool BrowseToplistRequest::has_region() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BrowseToplistRequest::set_has_region() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BrowseToplistRequest::clear_has_region() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BrowseToplistRequest::clear_region() {
  region_ = 1;
  clear_has_region();
}
inline ::pb::spotify::BrowseToplistRequest_Region BrowseToplistRequest::region() const {
  return static_cast< ::pb::spotify::BrowseToplistRequest_Region >(region_);
}
inline void BrowseToplistRequest::set_region(::pb::spotify::BrowseToplistRequest_Region value) {
  GOOGLE_DCHECK(::pb::spotify::BrowseToplistRequest_Region_IsValid(value));
  set_has_region();
  region_ = value;
}

// optional string username = 3;
inline bool BrowseToplistRequest::has_username() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BrowseToplistRequest::set_has_username() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BrowseToplistRequest::clear_has_username() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BrowseToplistRequest::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& BrowseToplistRequest::username() const {
  return *username_;
}
inline void BrowseToplistRequest::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void BrowseToplistRequest::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void BrowseToplistRequest::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BrowseToplistRequest::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* BrowseToplistRequest::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BrowseToplistResponse

// required .pb.spotify.BrowseToplistRequest request = 1;
inline bool BrowseToplistResponse::has_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BrowseToplistResponse::set_has_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BrowseToplistResponse::clear_has_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BrowseToplistResponse::clear_request() {
  if (request_ != NULL) request_->::pb::spotify::BrowseToplistRequest::Clear();
  clear_has_request();
}
inline const ::pb::spotify::BrowseToplistRequest& BrowseToplistResponse::request() const {
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::pb::spotify::BrowseToplistRequest* BrowseToplistResponse::mutable_request() {
  set_has_request();
  if (request_ == NULL) request_ = new ::pb::spotify::BrowseToplistRequest;
  return request_;
}
inline ::pb::spotify::BrowseToplistRequest* BrowseToplistResponse::release_request() {
  clear_has_request();
  ::pb::spotify::BrowseToplistRequest* temp = request_;
  request_ = NULL;
  return temp;
}

// repeated .pb.spotify.Track track = 2;
inline int BrowseToplistResponse::track_size() const {
  return track_.size();
}
inline void BrowseToplistResponse::clear_track() {
  track_.Clear();
}
inline const ::pb::spotify::Track& BrowseToplistResponse::track(int index) const {
  return track_.Get(index);
}
inline ::pb::spotify::Track* BrowseToplistResponse::mutable_track(int index) {
  return track_.Mutable(index);
}
inline ::pb::spotify::Track* BrowseToplistResponse::add_track() {
  return track_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::spotify::Track >&
BrowseToplistResponse::track() const {
  return track_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::spotify::Track >*
BrowseToplistResponse::mutable_track() {
  return &track_;
}

// repeated .pb.spotify.Album album = 3;
inline int BrowseToplistResponse::album_size() const {
  return album_.size();
}
inline void BrowseToplistResponse::clear_album() {
  album_.Clear();
}
inline const ::pb::spotify::Album& BrowseToplistResponse::album(int index) const {
  return album_.Get(index);
}
inline ::pb::spotify::Album* BrowseToplistResponse::mutable_album(int index) {
  return album_.Mutable(index);
}
inline ::pb::spotify::Album* BrowseToplistResponse::add_album() {
  return album_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::spotify::Album >&
BrowseToplistResponse::album() const {
  return album_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::spotify::Album >*
BrowseToplistResponse::mutable_album() {
  return &album_;
}

// -------------------------------------------------------------------

// SeekRequest

// optional int64 offset_bytes = 1;
inline bool SeekRequest::has_offset_bytes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SeekRequest::set_has_offset_bytes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SeekRequest::clear_has_offset_bytes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SeekRequest::clear_offset_bytes() {
  offset_bytes_ = GOOGLE_LONGLONG(0);
  clear_has_offset_bytes();
}
inline ::google::protobuf::int64 SeekRequest::offset_bytes() const {
  return offset_bytes_;
}
inline void SeekRequest::set_offset_bytes(::google::protobuf::int64 value) {
  set_has_offset_bytes();
  offset_bytes_ = value;
}

// -------------------------------------------------------------------

// PlaybackSettings

// optional .pb.spotify.Bitrate bitrate = 1 [default = Bitrate320k];
inline bool PlaybackSettings::has_bitrate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlaybackSettings::set_has_bitrate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlaybackSettings::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlaybackSettings::clear_bitrate() {
  bitrate_ = 3;
  clear_has_bitrate();
}
inline pb::spotify::Bitrate PlaybackSettings::bitrate() const {
  return static_cast< pb::spotify::Bitrate >(bitrate_);
}
inline void PlaybackSettings::set_bitrate(pb::spotify::Bitrate value) {
  GOOGLE_DCHECK(pb::spotify::Bitrate_IsValid(value));
  set_has_bitrate();
  bitrate_ = value;
}

// optional bool volume_normalisation = 2 [default = false];
inline bool PlaybackSettings::has_volume_normalisation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlaybackSettings::set_has_volume_normalisation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlaybackSettings::clear_has_volume_normalisation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlaybackSettings::clear_volume_normalisation() {
  volume_normalisation_ = false;
  clear_has_volume_normalisation();
}
inline bool PlaybackSettings::volume_normalisation() const {
  return volume_normalisation_;
}
inline void PlaybackSettings::set_volume_normalisation(bool value) {
  set_has_volume_normalisation();
  volume_normalisation_ = value;
}

// -------------------------------------------------------------------

// Message

// optional int32 id = 18;
inline bool Message::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Message::id() const {
  return id_;
}
inline void Message::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional .pb.spotify.LoginRequest login_request = 1;
inline bool Message::has_login_request() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_login_request() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_login_request() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_login_request() {
  if (login_request_ != NULL) login_request_->::pb::spotify::LoginRequest::Clear();
  clear_has_login_request();
}
inline const ::pb::spotify::LoginRequest& Message::login_request() const {
  return login_request_ != NULL ? *login_request_ : *default_instance_->login_request_;
}
inline ::pb::spotify::LoginRequest* Message::mutable_login_request() {
  set_has_login_request();
  if (login_request_ == NULL) login_request_ = new ::pb::spotify::LoginRequest;
  return login_request_;
}
inline ::pb::spotify::LoginRequest* Message::release_login_request() {
  clear_has_login_request();
  ::pb::spotify::LoginRequest* temp = login_request_;
  login_request_ = NULL;
  return temp;
}

// optional .pb.spotify.LoginResponse login_response = 2;
inline bool Message::has_login_response() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_login_response() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_login_response() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_login_response() {
  if (login_response_ != NULL) login_response_->::pb::spotify::LoginResponse::Clear();
  clear_has_login_response();
}
inline const ::pb::spotify::LoginResponse& Message::login_response() const {
  return login_response_ != NULL ? *login_response_ : *default_instance_->login_response_;
}
inline ::pb::spotify::LoginResponse* Message::mutable_login_response() {
  set_has_login_response();
  if (login_response_ == NULL) login_response_ = new ::pb::spotify::LoginResponse;
  return login_response_;
}
inline ::pb::spotify::LoginResponse* Message::release_login_response() {
  clear_has_login_response();
  ::pb::spotify::LoginResponse* temp = login_response_;
  login_response_ = NULL;
  return temp;
}

// optional .pb.spotify.Playlists playlists_updated = 3;
inline bool Message::has_playlists_updated() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_playlists_updated() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_playlists_updated() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_playlists_updated() {
  if (playlists_updated_ != NULL) playlists_updated_->::pb::spotify::Playlists::Clear();
  clear_has_playlists_updated();
}
inline const ::pb::spotify::Playlists& Message::playlists_updated() const {
  return playlists_updated_ != NULL ? *playlists_updated_ : *default_instance_->playlists_updated_;
}
inline ::pb::spotify::Playlists* Message::mutable_playlists_updated() {
  set_has_playlists_updated();
  if (playlists_updated_ == NULL) playlists_updated_ = new ::pb::spotify::Playlists;
  return playlists_updated_;
}
inline ::pb::spotify::Playlists* Message::release_playlists_updated() {
  clear_has_playlists_updated();
  ::pb::spotify::Playlists* temp = playlists_updated_;
  playlists_updated_ = NULL;
  return temp;
}

// optional .pb.spotify.LoadPlaylistRequest load_playlist_request = 4;
inline bool Message::has_load_playlist_request() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message::set_has_load_playlist_request() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message::clear_has_load_playlist_request() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message::clear_load_playlist_request() {
  if (load_playlist_request_ != NULL) load_playlist_request_->::pb::spotify::LoadPlaylistRequest::Clear();
  clear_has_load_playlist_request();
}
inline const ::pb::spotify::LoadPlaylistRequest& Message::load_playlist_request() const {
  return load_playlist_request_ != NULL ? *load_playlist_request_ : *default_instance_->load_playlist_request_;
}
inline ::pb::spotify::LoadPlaylistRequest* Message::mutable_load_playlist_request() {
  set_has_load_playlist_request();
  if (load_playlist_request_ == NULL) load_playlist_request_ = new ::pb::spotify::LoadPlaylistRequest;
  return load_playlist_request_;
}
inline ::pb::spotify::LoadPlaylistRequest* Message::release_load_playlist_request() {
  clear_has_load_playlist_request();
  ::pb::spotify::LoadPlaylistRequest* temp = load_playlist_request_;
  load_playlist_request_ = NULL;
  return temp;
}

// optional .pb.spotify.LoadPlaylistResponse load_playlist_response = 5;
inline bool Message::has_load_playlist_response() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message::set_has_load_playlist_response() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message::clear_has_load_playlist_response() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message::clear_load_playlist_response() {
  if (load_playlist_response_ != NULL) load_playlist_response_->::pb::spotify::LoadPlaylistResponse::Clear();
  clear_has_load_playlist_response();
}
inline const ::pb::spotify::LoadPlaylistResponse& Message::load_playlist_response() const {
  return load_playlist_response_ != NULL ? *load_playlist_response_ : *default_instance_->load_playlist_response_;
}
inline ::pb::spotify::LoadPlaylistResponse* Message::mutable_load_playlist_response() {
  set_has_load_playlist_response();
  if (load_playlist_response_ == NULL) load_playlist_response_ = new ::pb::spotify::LoadPlaylistResponse;
  return load_playlist_response_;
}
inline ::pb::spotify::LoadPlaylistResponse* Message::release_load_playlist_response() {
  clear_has_load_playlist_response();
  ::pb::spotify::LoadPlaylistResponse* temp = load_playlist_response_;
  load_playlist_response_ = NULL;
  return temp;
}

// optional .pb.spotify.PlaybackRequest playback_request = 6;
inline bool Message::has_playback_request() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Message::set_has_playback_request() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Message::clear_has_playback_request() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Message::clear_playback_request() {
  if (playback_request_ != NULL) playback_request_->::pb::spotify::PlaybackRequest::Clear();
  clear_has_playback_request();
}
inline const ::pb::spotify::PlaybackRequest& Message::playback_request() const {
  return playback_request_ != NULL ? *playback_request_ : *default_instance_->playback_request_;
}
inline ::pb::spotify::PlaybackRequest* Message::mutable_playback_request() {
  set_has_playback_request();
  if (playback_request_ == NULL) playback_request_ = new ::pb::spotify::PlaybackRequest;
  return playback_request_;
}
inline ::pb::spotify::PlaybackRequest* Message::release_playback_request() {
  clear_has_playback_request();
  ::pb::spotify::PlaybackRequest* temp = playback_request_;
  playback_request_ = NULL;
  return temp;
}

// optional .pb.spotify.PlaybackError playback_error = 7;
inline bool Message::has_playback_error() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Message::set_has_playback_error() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Message::clear_has_playback_error() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Message::clear_playback_error() {
  if (playback_error_ != NULL) playback_error_->::pb::spotify::PlaybackError::Clear();
  clear_has_playback_error();
}
inline const ::pb::spotify::PlaybackError& Message::playback_error() const {
  return playback_error_ != NULL ? *playback_error_ : *default_instance_->playback_error_;
}
inline ::pb::spotify::PlaybackError* Message::mutable_playback_error() {
  set_has_playback_error();
  if (playback_error_ == NULL) playback_error_ = new ::pb::spotify::PlaybackError;
  return playback_error_;
}
inline ::pb::spotify::PlaybackError* Message::release_playback_error() {
  clear_has_playback_error();
  ::pb::spotify::PlaybackError* temp = playback_error_;
  playback_error_ = NULL;
  return temp;
}

// optional .pb.spotify.SearchRequest search_request = 8;
inline bool Message::has_search_request() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Message::set_has_search_request() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Message::clear_has_search_request() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Message::clear_search_request() {
  if (search_request_ != NULL) search_request_->::pb::spotify::SearchRequest::Clear();
  clear_has_search_request();
}
inline const ::pb::spotify::SearchRequest& Message::search_request() const {
  return search_request_ != NULL ? *search_request_ : *default_instance_->search_request_;
}
inline ::pb::spotify::SearchRequest* Message::mutable_search_request() {
  set_has_search_request();
  if (search_request_ == NULL) search_request_ = new ::pb::spotify::SearchRequest;
  return search_request_;
}
inline ::pb::spotify::SearchRequest* Message::release_search_request() {
  clear_has_search_request();
  ::pb::spotify::SearchRequest* temp = search_request_;
  search_request_ = NULL;
  return temp;
}

// optional .pb.spotify.SearchResponse search_response = 9;
inline bool Message::has_search_response() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Message::set_has_search_response() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Message::clear_has_search_response() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Message::clear_search_response() {
  if (search_response_ != NULL) search_response_->::pb::spotify::SearchResponse::Clear();
  clear_has_search_response();
}
inline const ::pb::spotify::SearchResponse& Message::search_response() const {
  return search_response_ != NULL ? *search_response_ : *default_instance_->search_response_;
}
inline ::pb::spotify::SearchResponse* Message::mutable_search_response() {
  set_has_search_response();
  if (search_response_ == NULL) search_response_ = new ::pb::spotify::SearchResponse;
  return search_response_;
}
inline ::pb::spotify::SearchResponse* Message::release_search_response() {
  clear_has_search_response();
  ::pb::spotify::SearchResponse* temp = search_response_;
  search_response_ = NULL;
  return temp;
}

// optional .pb.spotify.ImageRequest image_request = 10;
inline bool Message::has_image_request() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Message::set_has_image_request() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Message::clear_has_image_request() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Message::clear_image_request() {
  if (image_request_ != NULL) image_request_->::pb::spotify::ImageRequest::Clear();
  clear_has_image_request();
}
inline const ::pb::spotify::ImageRequest& Message::image_request() const {
  return image_request_ != NULL ? *image_request_ : *default_instance_->image_request_;
}
inline ::pb::spotify::ImageRequest* Message::mutable_image_request() {
  set_has_image_request();
  if (image_request_ == NULL) image_request_ = new ::pb::spotify::ImageRequest;
  return image_request_;
}
inline ::pb::spotify::ImageRequest* Message::release_image_request() {
  clear_has_image_request();
  ::pb::spotify::ImageRequest* temp = image_request_;
  image_request_ = NULL;
  return temp;
}

// optional .pb.spotify.ImageResponse image_response = 11;
inline bool Message::has_image_response() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Message::set_has_image_response() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Message::clear_has_image_response() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Message::clear_image_response() {
  if (image_response_ != NULL) image_response_->::pb::spotify::ImageResponse::Clear();
  clear_has_image_response();
}
inline const ::pb::spotify::ImageResponse& Message::image_response() const {
  return image_response_ != NULL ? *image_response_ : *default_instance_->image_response_;
}
inline ::pb::spotify::ImageResponse* Message::mutable_image_response() {
  set_has_image_response();
  if (image_response_ == NULL) image_response_ = new ::pb::spotify::ImageResponse;
  return image_response_;
}
inline ::pb::spotify::ImageResponse* Message::release_image_response() {
  clear_has_image_response();
  ::pb::spotify::ImageResponse* temp = image_response_;
  image_response_ = NULL;
  return temp;
}

// optional .pb.spotify.SyncPlaylistRequest sync_playlist_request = 12;
inline bool Message::has_sync_playlist_request() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Message::set_has_sync_playlist_request() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Message::clear_has_sync_playlist_request() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Message::clear_sync_playlist_request() {
  if (sync_playlist_request_ != NULL) sync_playlist_request_->::pb::spotify::SyncPlaylistRequest::Clear();
  clear_has_sync_playlist_request();
}
inline const ::pb::spotify::SyncPlaylistRequest& Message::sync_playlist_request() const {
  return sync_playlist_request_ != NULL ? *sync_playlist_request_ : *default_instance_->sync_playlist_request_;
}
inline ::pb::spotify::SyncPlaylistRequest* Message::mutable_sync_playlist_request() {
  set_has_sync_playlist_request();
  if (sync_playlist_request_ == NULL) sync_playlist_request_ = new ::pb::spotify::SyncPlaylistRequest;
  return sync_playlist_request_;
}
inline ::pb::spotify::SyncPlaylistRequest* Message::release_sync_playlist_request() {
  clear_has_sync_playlist_request();
  ::pb::spotify::SyncPlaylistRequest* temp = sync_playlist_request_;
  sync_playlist_request_ = NULL;
  return temp;
}

// optional .pb.spotify.SyncPlaylistProgress sync_playlist_progress = 13;
inline bool Message::has_sync_playlist_progress() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Message::set_has_sync_playlist_progress() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Message::clear_has_sync_playlist_progress() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Message::clear_sync_playlist_progress() {
  if (sync_playlist_progress_ != NULL) sync_playlist_progress_->::pb::spotify::SyncPlaylistProgress::Clear();
  clear_has_sync_playlist_progress();
}
inline const ::pb::spotify::SyncPlaylistProgress& Message::sync_playlist_progress() const {
  return sync_playlist_progress_ != NULL ? *sync_playlist_progress_ : *default_instance_->sync_playlist_progress_;
}
inline ::pb::spotify::SyncPlaylistProgress* Message::mutable_sync_playlist_progress() {
  set_has_sync_playlist_progress();
  if (sync_playlist_progress_ == NULL) sync_playlist_progress_ = new ::pb::spotify::SyncPlaylistProgress;
  return sync_playlist_progress_;
}
inline ::pb::spotify::SyncPlaylistProgress* Message::release_sync_playlist_progress() {
  clear_has_sync_playlist_progress();
  ::pb::spotify::SyncPlaylistProgress* temp = sync_playlist_progress_;
  sync_playlist_progress_ = NULL;
  return temp;
}

// optional .pb.spotify.BrowseAlbumRequest browse_album_request = 14;
inline bool Message::has_browse_album_request() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Message::set_has_browse_album_request() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Message::clear_has_browse_album_request() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Message::clear_browse_album_request() {
  if (browse_album_request_ != NULL) browse_album_request_->::pb::spotify::BrowseAlbumRequest::Clear();
  clear_has_browse_album_request();
}
inline const ::pb::spotify::BrowseAlbumRequest& Message::browse_album_request() const {
  return browse_album_request_ != NULL ? *browse_album_request_ : *default_instance_->browse_album_request_;
}
inline ::pb::spotify::BrowseAlbumRequest* Message::mutable_browse_album_request() {
  set_has_browse_album_request();
  if (browse_album_request_ == NULL) browse_album_request_ = new ::pb::spotify::BrowseAlbumRequest;
  return browse_album_request_;
}
inline ::pb::spotify::BrowseAlbumRequest* Message::release_browse_album_request() {
  clear_has_browse_album_request();
  ::pb::spotify::BrowseAlbumRequest* temp = browse_album_request_;
  browse_album_request_ = NULL;
  return temp;
}

// optional .pb.spotify.BrowseAlbumResponse browse_album_response = 15;
inline bool Message::has_browse_album_response() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Message::set_has_browse_album_response() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Message::clear_has_browse_album_response() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Message::clear_browse_album_response() {
  if (browse_album_response_ != NULL) browse_album_response_->::pb::spotify::BrowseAlbumResponse::Clear();
  clear_has_browse_album_response();
}
inline const ::pb::spotify::BrowseAlbumResponse& Message::browse_album_response() const {
  return browse_album_response_ != NULL ? *browse_album_response_ : *default_instance_->browse_album_response_;
}
inline ::pb::spotify::BrowseAlbumResponse* Message::mutable_browse_album_response() {
  set_has_browse_album_response();
  if (browse_album_response_ == NULL) browse_album_response_ = new ::pb::spotify::BrowseAlbumResponse;
  return browse_album_response_;
}
inline ::pb::spotify::BrowseAlbumResponse* Message::release_browse_album_response() {
  clear_has_browse_album_response();
  ::pb::spotify::BrowseAlbumResponse* temp = browse_album_response_;
  browse_album_response_ = NULL;
  return temp;
}

// optional .pb.spotify.SeekRequest seek_request = 16;
inline bool Message::has_seek_request() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Message::set_has_seek_request() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Message::clear_has_seek_request() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Message::clear_seek_request() {
  if (seek_request_ != NULL) seek_request_->::pb::spotify::SeekRequest::Clear();
  clear_has_seek_request();
}
inline const ::pb::spotify::SeekRequest& Message::seek_request() const {
  return seek_request_ != NULL ? *seek_request_ : *default_instance_->seek_request_;
}
inline ::pb::spotify::SeekRequest* Message::mutable_seek_request() {
  set_has_seek_request();
  if (seek_request_ == NULL) seek_request_ = new ::pb::spotify::SeekRequest;
  return seek_request_;
}
inline ::pb::spotify::SeekRequest* Message::release_seek_request() {
  clear_has_seek_request();
  ::pb::spotify::SeekRequest* temp = seek_request_;
  seek_request_ = NULL;
  return temp;
}

// optional .pb.spotify.PlaybackSettings set_playback_settings_request = 17;
inline bool Message::has_set_playback_settings_request() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Message::set_has_set_playback_settings_request() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Message::clear_has_set_playback_settings_request() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Message::clear_set_playback_settings_request() {
  if (set_playback_settings_request_ != NULL) set_playback_settings_request_->::pb::spotify::PlaybackSettings::Clear();
  clear_has_set_playback_settings_request();
}
inline const ::pb::spotify::PlaybackSettings& Message::set_playback_settings_request() const {
  return set_playback_settings_request_ != NULL ? *set_playback_settings_request_ : *default_instance_->set_playback_settings_request_;
}
inline ::pb::spotify::PlaybackSettings* Message::mutable_set_playback_settings_request() {
  set_has_set_playback_settings_request();
  if (set_playback_settings_request_ == NULL) set_playback_settings_request_ = new ::pb::spotify::PlaybackSettings;
  return set_playback_settings_request_;
}
inline ::pb::spotify::PlaybackSettings* Message::release_set_playback_settings_request() {
  clear_has_set_playback_settings_request();
  ::pb::spotify::PlaybackSettings* temp = set_playback_settings_request_;
  set_playback_settings_request_ = NULL;
  return temp;
}

// optional .pb.spotify.BrowseToplistRequest browse_toplist_request = 19;
inline bool Message::has_browse_toplist_request() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Message::set_has_browse_toplist_request() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Message::clear_has_browse_toplist_request() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Message::clear_browse_toplist_request() {
  if (browse_toplist_request_ != NULL) browse_toplist_request_->::pb::spotify::BrowseToplistRequest::Clear();
  clear_has_browse_toplist_request();
}
inline const ::pb::spotify::BrowseToplistRequest& Message::browse_toplist_request() const {
  return browse_toplist_request_ != NULL ? *browse_toplist_request_ : *default_instance_->browse_toplist_request_;
}
inline ::pb::spotify::BrowseToplistRequest* Message::mutable_browse_toplist_request() {
  set_has_browse_toplist_request();
  if (browse_toplist_request_ == NULL) browse_toplist_request_ = new ::pb::spotify::BrowseToplistRequest;
  return browse_toplist_request_;
}
inline ::pb::spotify::BrowseToplistRequest* Message::release_browse_toplist_request() {
  clear_has_browse_toplist_request();
  ::pb::spotify::BrowseToplistRequest* temp = browse_toplist_request_;
  browse_toplist_request_ = NULL;
  return temp;
}

// optional .pb.spotify.BrowseToplistResponse browse_toplist_response = 20;
inline bool Message::has_browse_toplist_response() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Message::set_has_browse_toplist_response() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Message::clear_has_browse_toplist_response() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Message::clear_browse_toplist_response() {
  if (browse_toplist_response_ != NULL) browse_toplist_response_->::pb::spotify::BrowseToplistResponse::Clear();
  clear_has_browse_toplist_response();
}
inline const ::pb::spotify::BrowseToplistResponse& Message::browse_toplist_response() const {
  return browse_toplist_response_ != NULL ? *browse_toplist_response_ : *default_instance_->browse_toplist_response_;
}
inline ::pb::spotify::BrowseToplistResponse* Message::mutable_browse_toplist_response() {
  set_has_browse_toplist_response();
  if (browse_toplist_response_ == NULL) browse_toplist_response_ = new ::pb::spotify::BrowseToplistResponse;
  return browse_toplist_response_;
}
inline ::pb::spotify::BrowseToplistResponse* Message::release_browse_toplist_response() {
  clear_has_browse_toplist_response();
  ::pb::spotify::BrowseToplistResponse* temp = browse_toplist_response_;
  browse_toplist_response_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace spotify
}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::spotify::LoginResponse_Error>() {
  return ::pb::spotify::LoginResponse_Error_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::spotify::BrowseToplistRequest_ToplistType>() {
  return ::pb::spotify::BrowseToplistRequest_ToplistType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::spotify::BrowseToplistRequest_Region>() {
  return ::pb::spotify::BrowseToplistRequest_Region_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< pb::spotify::PlaylistType>() {
  return pb::spotify::PlaylistType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< pb::spotify::Bitrate>() {
  return pb::spotify::Bitrate_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_spotifymessages_2eproto__INCLUDED
