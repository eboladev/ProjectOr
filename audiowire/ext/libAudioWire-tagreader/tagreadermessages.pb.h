// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tagreadermessages.proto

#ifndef PROTOBUF_tagreadermessages_2eproto__INCLUDED
#define PROTOBUF_tagreadermessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace pb {
namespace tagreader {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_tagreadermessages_2eproto();
void protobuf_AssignDesc_tagreadermessages_2eproto();
void protobuf_ShutdownFile_tagreadermessages_2eproto();

class SongMetadata;
class ReadFileRequest;
class ReadFileResponse;
class SaveFileRequest;
class SaveFileResponse;
class IsMediaFileRequest;
class IsMediaFileResponse;
class LoadEmbeddedArtRequest;
class LoadEmbeddedArtResponse;
class ReadGoogleDriveRequest;
class ReadGoogleDriveResponse;
class Message;

enum SongMetadata_Type {
  SongMetadata_Type_UNKNOWN = 0,
  SongMetadata_Type_ASF = 1,
  SongMetadata_Type_FLAC = 2,
  SongMetadata_Type_MP4 = 3,
  SongMetadata_Type_MPC = 4,
  SongMetadata_Type_MPEG = 5,
  SongMetadata_Type_OGGFLAC = 6,
  SongMetadata_Type_OGGSPEEX = 7,
  SongMetadata_Type_OGGVORBIS = 8,
  SongMetadata_Type_AIFF = 9,
  SongMetadata_Type_WAV = 10,
  SongMetadata_Type_TRUEAUDIO = 11,
  SongMetadata_Type_CDDA = 12,
  SongMetadata_Type_STREAM = 99
};
bool SongMetadata_Type_IsValid(int value);
const SongMetadata_Type SongMetadata_Type_Type_MIN = SongMetadata_Type_UNKNOWN;
const SongMetadata_Type SongMetadata_Type_Type_MAX = SongMetadata_Type_STREAM;
const int SongMetadata_Type_Type_ARRAYSIZE = SongMetadata_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* SongMetadata_Type_descriptor();
inline const ::std::string& SongMetadata_Type_Name(SongMetadata_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    SongMetadata_Type_descriptor(), value);
}
inline bool SongMetadata_Type_Parse(
    const ::std::string& name, SongMetadata_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SongMetadata_Type>(
    SongMetadata_Type_descriptor(), name, value);
}
// ===================================================================

class SongMetadata : public ::google::protobuf::Message {
 public:
  SongMetadata();
  virtual ~SongMetadata();
  
  SongMetadata(const SongMetadata& from);
  
  inline SongMetadata& operator=(const SongMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SongMetadata& default_instance();
  
  void Swap(SongMetadata* other);
  
  // implements Message ----------------------------------------------
  
  SongMetadata* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SongMetadata& from);
  void MergeFrom(const SongMetadata& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef SongMetadata_Type Type;
  static const Type UNKNOWN = SongMetadata_Type_UNKNOWN;
  static const Type ASF = SongMetadata_Type_ASF;
  static const Type FLAC = SongMetadata_Type_FLAC;
  static const Type MP4 = SongMetadata_Type_MP4;
  static const Type MPC = SongMetadata_Type_MPC;
  static const Type MPEG = SongMetadata_Type_MPEG;
  static const Type OGGFLAC = SongMetadata_Type_OGGFLAC;
  static const Type OGGSPEEX = SongMetadata_Type_OGGSPEEX;
  static const Type OGGVORBIS = SongMetadata_Type_OGGVORBIS;
  static const Type AIFF = SongMetadata_Type_AIFF;
  static const Type WAV = SongMetadata_Type_WAV;
  static const Type TRUEAUDIO = SongMetadata_Type_TRUEAUDIO;
  static const Type CDDA = SongMetadata_Type_CDDA;
  static const Type STREAM = SongMetadata_Type_STREAM;
  static inline bool Type_IsValid(int value) {
    return SongMetadata_Type_IsValid(value);
  }
  static const Type Type_MIN =
    SongMetadata_Type_Type_MIN;
  static const Type Type_MAX =
    SongMetadata_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    SongMetadata_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return SongMetadata_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return SongMetadata_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return SongMetadata_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional bool valid = 1;
  inline bool has_valid() const;
  inline void clear_valid();
  static const int kValidFieldNumber = 1;
  inline bool valid() const;
  inline void set_valid(bool value);
  
  // optional string title = 2;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 2;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  
  // optional string album = 3;
  inline bool has_album() const;
  inline void clear_album();
  static const int kAlbumFieldNumber = 3;
  inline const ::std::string& album() const;
  inline void set_album(const ::std::string& value);
  inline void set_album(const char* value);
  inline void set_album(const char* value, size_t size);
  inline ::std::string* mutable_album();
  inline ::std::string* release_album();
  
  // optional string artist = 4;
  inline bool has_artist() const;
  inline void clear_artist();
  static const int kArtistFieldNumber = 4;
  inline const ::std::string& artist() const;
  inline void set_artist(const ::std::string& value);
  inline void set_artist(const char* value);
  inline void set_artist(const char* value, size_t size);
  inline ::std::string* mutable_artist();
  inline ::std::string* release_artist();
  
  // optional string albumartist = 5;
  inline bool has_albumartist() const;
  inline void clear_albumartist();
  static const int kAlbumartistFieldNumber = 5;
  inline const ::std::string& albumartist() const;
  inline void set_albumartist(const ::std::string& value);
  inline void set_albumartist(const char* value);
  inline void set_albumartist(const char* value, size_t size);
  inline ::std::string* mutable_albumartist();
  inline ::std::string* release_albumartist();
  
  // optional string composer = 6;
  inline bool has_composer() const;
  inline void clear_composer();
  static const int kComposerFieldNumber = 6;
  inline const ::std::string& composer() const;
  inline void set_composer(const ::std::string& value);
  inline void set_composer(const char* value);
  inline void set_composer(const char* value, size_t size);
  inline ::std::string* mutable_composer();
  inline ::std::string* release_composer();
  
  // optional int32 track = 7;
  inline bool has_track() const;
  inline void clear_track();
  static const int kTrackFieldNumber = 7;
  inline ::google::protobuf::int32 track() const;
  inline void set_track(::google::protobuf::int32 value);
  
  // optional int32 disc = 8;
  inline bool has_disc() const;
  inline void clear_disc();
  static const int kDiscFieldNumber = 8;
  inline ::google::protobuf::int32 disc() const;
  inline void set_disc(::google::protobuf::int32 value);
  
  // optional float bpm = 9;
  inline bool has_bpm() const;
  inline void clear_bpm();
  static const int kBpmFieldNumber = 9;
  inline float bpm() const;
  inline void set_bpm(float value);
  
  // optional int32 year = 10;
  inline bool has_year() const;
  inline void clear_year();
  static const int kYearFieldNumber = 10;
  inline ::google::protobuf::int32 year() const;
  inline void set_year(::google::protobuf::int32 value);
  
  // optional string genre = 11;
  inline bool has_genre() const;
  inline void clear_genre();
  static const int kGenreFieldNumber = 11;
  inline const ::std::string& genre() const;
  inline void set_genre(const ::std::string& value);
  inline void set_genre(const char* value);
  inline void set_genre(const char* value, size_t size);
  inline ::std::string* mutable_genre();
  inline ::std::string* release_genre();
  
  // optional string comment = 12;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 12;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  
  // optional bool compilation = 13;
  inline bool has_compilation() const;
  inline void clear_compilation();
  static const int kCompilationFieldNumber = 13;
  inline bool compilation() const;
  inline void set_compilation(bool value);
  
  // optional float rating = 14;
  inline bool has_rating() const;
  inline void clear_rating();
  static const int kRatingFieldNumber = 14;
  inline float rating() const;
  inline void set_rating(float value);
  
  // optional int32 playcount = 15;
  inline bool has_playcount() const;
  inline void clear_playcount();
  static const int kPlaycountFieldNumber = 15;
  inline ::google::protobuf::int32 playcount() const;
  inline void set_playcount(::google::protobuf::int32 value);
  
  // optional int32 skipcount = 16;
  inline bool has_skipcount() const;
  inline void clear_skipcount();
  static const int kSkipcountFieldNumber = 16;
  inline ::google::protobuf::int32 skipcount() const;
  inline void set_skipcount(::google::protobuf::int32 value);
  
  // optional int32 lastplayed = 17;
  inline bool has_lastplayed() const;
  inline void clear_lastplayed();
  static const int kLastplayedFieldNumber = 17;
  inline ::google::protobuf::int32 lastplayed() const;
  inline void set_lastplayed(::google::protobuf::int32 value);
  
  // optional int32 score = 18;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 18;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);
  
  // optional uint64 length_nanosec = 19;
  inline bool has_length_nanosec() const;
  inline void clear_length_nanosec();
  static const int kLengthNanosecFieldNumber = 19;
  inline ::google::protobuf::uint64 length_nanosec() const;
  inline void set_length_nanosec(::google::protobuf::uint64 value);
  
  // optional int32 bitrate = 20;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 20;
  inline ::google::protobuf::int32 bitrate() const;
  inline void set_bitrate(::google::protobuf::int32 value);
  
  // optional int32 samplerate = 21;
  inline bool has_samplerate() const;
  inline void clear_samplerate();
  static const int kSamplerateFieldNumber = 21;
  inline ::google::protobuf::int32 samplerate() const;
  inline void set_samplerate(::google::protobuf::int32 value);
  
  // optional string url = 22;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 22;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  
  // optional string basefilename = 23;
  inline bool has_basefilename() const;
  inline void clear_basefilename();
  static const int kBasefilenameFieldNumber = 23;
  inline const ::std::string& basefilename() const;
  inline void set_basefilename(const ::std::string& value);
  inline void set_basefilename(const char* value);
  inline void set_basefilename(const char* value, size_t size);
  inline ::std::string* mutable_basefilename();
  inline ::std::string* release_basefilename();
  
  // optional int32 mtime = 24;
  inline bool has_mtime() const;
  inline void clear_mtime();
  static const int kMtimeFieldNumber = 24;
  inline ::google::protobuf::int32 mtime() const;
  inline void set_mtime(::google::protobuf::int32 value);
  
  // optional int32 ctime = 25;
  inline bool has_ctime() const;
  inline void clear_ctime();
  static const int kCtimeFieldNumber = 25;
  inline ::google::protobuf::int32 ctime() const;
  inline void set_ctime(::google::protobuf::int32 value);
  
  // optional int32 filesize = 26;
  inline bool has_filesize() const;
  inline void clear_filesize();
  static const int kFilesizeFieldNumber = 26;
  inline ::google::protobuf::int32 filesize() const;
  inline void set_filesize(::google::protobuf::int32 value);
  
  // optional bool suspicious_tags = 27;
  inline bool has_suspicious_tags() const;
  inline void clear_suspicious_tags();
  static const int kSuspiciousTagsFieldNumber = 27;
  inline bool suspicious_tags() const;
  inline void set_suspicious_tags(bool value);
  
  // optional string art_automatic = 28;
  inline bool has_art_automatic() const;
  inline void clear_art_automatic();
  static const int kArtAutomaticFieldNumber = 28;
  inline const ::std::string& art_automatic() const;
  inline void set_art_automatic(const ::std::string& value);
  inline void set_art_automatic(const char* value);
  inline void set_art_automatic(const char* value, size_t size);
  inline ::std::string* mutable_art_automatic();
  inline ::std::string* release_art_automatic();
  
  // optional .pb.tagreader.SongMetadata.Type type = 29;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 29;
  inline ::pb::tagreader::SongMetadata_Type type() const;
  inline void set_type(::pb::tagreader::SongMetadata_Type value);
  
  // @@protoc_insertion_point(class_scope:pb.tagreader.SongMetadata)
 private:
  inline void set_has_valid();
  inline void clear_has_valid();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_album();
  inline void clear_has_album();
  inline void set_has_artist();
  inline void clear_has_artist();
  inline void set_has_albumartist();
  inline void clear_has_albumartist();
  inline void set_has_composer();
  inline void clear_has_composer();
  inline void set_has_track();
  inline void clear_has_track();
  inline void set_has_disc();
  inline void clear_has_disc();
  inline void set_has_bpm();
  inline void clear_has_bpm();
  inline void set_has_year();
  inline void clear_has_year();
  inline void set_has_genre();
  inline void clear_has_genre();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_compilation();
  inline void clear_has_compilation();
  inline void set_has_rating();
  inline void clear_has_rating();
  inline void set_has_playcount();
  inline void clear_has_playcount();
  inline void set_has_skipcount();
  inline void clear_has_skipcount();
  inline void set_has_lastplayed();
  inline void clear_has_lastplayed();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_length_nanosec();
  inline void clear_has_length_nanosec();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();
  inline void set_has_samplerate();
  inline void clear_has_samplerate();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_basefilename();
  inline void clear_has_basefilename();
  inline void set_has_mtime();
  inline void clear_has_mtime();
  inline void set_has_ctime();
  inline void clear_has_ctime();
  inline void set_has_filesize();
  inline void clear_has_filesize();
  inline void set_has_suspicious_tags();
  inline void clear_has_suspicious_tags();
  inline void set_has_art_automatic();
  inline void clear_has_art_automatic();
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* title_;
  ::std::string* album_;
  ::std::string* artist_;
  ::std::string* albumartist_;
  ::std::string* composer_;
  ::google::protobuf::int32 track_;
  ::google::protobuf::int32 disc_;
  float bpm_;
  ::google::protobuf::int32 year_;
  ::std::string* genre_;
  ::std::string* comment_;
  bool valid_;
  bool compilation_;
  bool suspicious_tags_;
  float rating_;
  ::google::protobuf::int32 playcount_;
  ::google::protobuf::int32 skipcount_;
  ::google::protobuf::int32 lastplayed_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::uint64 length_nanosec_;
  ::google::protobuf::int32 bitrate_;
  ::google::protobuf::int32 samplerate_;
  ::std::string* url_;
  ::std::string* basefilename_;
  ::google::protobuf::int32 mtime_;
  ::google::protobuf::int32 ctime_;
  ::google::protobuf::int32 filesize_;
  int type_;
  ::std::string* art_automatic_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(29 + 31) / 32];
  
  friend void  protobuf_AddDesc_tagreadermessages_2eproto();
  friend void protobuf_AssignDesc_tagreadermessages_2eproto();
  friend void protobuf_ShutdownFile_tagreadermessages_2eproto();
  
  void InitAsDefaultInstance();
  static SongMetadata* default_instance_;
};
// -------------------------------------------------------------------

class ReadFileRequest : public ::google::protobuf::Message {
 public:
  ReadFileRequest();
  virtual ~ReadFileRequest();
  
  ReadFileRequest(const ReadFileRequest& from);
  
  inline ReadFileRequest& operator=(const ReadFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadFileRequest& default_instance();
  
  void Swap(ReadFileRequest* other);
  
  // implements Message ----------------------------------------------
  
  ReadFileRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReadFileRequest& from);
  void MergeFrom(const ReadFileRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string filename = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  
  // @@protoc_insertion_point(class_scope:pb.tagreader.ReadFileRequest)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* filename_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_tagreadermessages_2eproto();
  friend void protobuf_AssignDesc_tagreadermessages_2eproto();
  friend void protobuf_ShutdownFile_tagreadermessages_2eproto();
  
  void InitAsDefaultInstance();
  static ReadFileRequest* default_instance_;
};
// -------------------------------------------------------------------

class ReadFileResponse : public ::google::protobuf::Message {
 public:
  ReadFileResponse();
  virtual ~ReadFileResponse();
  
  ReadFileResponse(const ReadFileResponse& from);
  
  inline ReadFileResponse& operator=(const ReadFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadFileResponse& default_instance();
  
  void Swap(ReadFileResponse* other);
  
  // implements Message ----------------------------------------------
  
  ReadFileResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReadFileResponse& from);
  void MergeFrom(const ReadFileResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .pb.tagreader.SongMetadata metadata = 1;
  inline bool has_metadata() const;
  inline void clear_metadata();
  static const int kMetadataFieldNumber = 1;
  inline const ::pb::tagreader::SongMetadata& metadata() const;
  inline ::pb::tagreader::SongMetadata* mutable_metadata();
  inline ::pb::tagreader::SongMetadata* release_metadata();
  
  // @@protoc_insertion_point(class_scope:pb.tagreader.ReadFileResponse)
 private:
  inline void set_has_metadata();
  inline void clear_has_metadata();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::pb::tagreader::SongMetadata* metadata_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_tagreadermessages_2eproto();
  friend void protobuf_AssignDesc_tagreadermessages_2eproto();
  friend void protobuf_ShutdownFile_tagreadermessages_2eproto();
  
  void InitAsDefaultInstance();
  static ReadFileResponse* default_instance_;
};
// -------------------------------------------------------------------

class SaveFileRequest : public ::google::protobuf::Message {
 public:
  SaveFileRequest();
  virtual ~SaveFileRequest();
  
  SaveFileRequest(const SaveFileRequest& from);
  
  inline SaveFileRequest& operator=(const SaveFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SaveFileRequest& default_instance();
  
  void Swap(SaveFileRequest* other);
  
  // implements Message ----------------------------------------------
  
  SaveFileRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SaveFileRequest& from);
  void MergeFrom(const SaveFileRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string filename = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  
  // optional .pb.tagreader.SongMetadata metadata = 2;
  inline bool has_metadata() const;
  inline void clear_metadata();
  static const int kMetadataFieldNumber = 2;
  inline const ::pb::tagreader::SongMetadata& metadata() const;
  inline ::pb::tagreader::SongMetadata* mutable_metadata();
  inline ::pb::tagreader::SongMetadata* release_metadata();
  
  // @@protoc_insertion_point(class_scope:pb.tagreader.SaveFileRequest)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_metadata();
  inline void clear_has_metadata();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* filename_;
  ::pb::tagreader::SongMetadata* metadata_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_tagreadermessages_2eproto();
  friend void protobuf_AssignDesc_tagreadermessages_2eproto();
  friend void protobuf_ShutdownFile_tagreadermessages_2eproto();
  
  void InitAsDefaultInstance();
  static SaveFileRequest* default_instance_;
};
// -------------------------------------------------------------------

class SaveFileResponse : public ::google::protobuf::Message {
 public:
  SaveFileResponse();
  virtual ~SaveFileResponse();
  
  SaveFileResponse(const SaveFileResponse& from);
  
  inline SaveFileResponse& operator=(const SaveFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SaveFileResponse& default_instance();
  
  void Swap(SaveFileResponse* other);
  
  // implements Message ----------------------------------------------
  
  SaveFileResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SaveFileResponse& from);
  void MergeFrom(const SaveFileResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);
  
  // @@protoc_insertion_point(class_scope:pb.tagreader.SaveFileResponse)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool success_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_tagreadermessages_2eproto();
  friend void protobuf_AssignDesc_tagreadermessages_2eproto();
  friend void protobuf_ShutdownFile_tagreadermessages_2eproto();
  
  void InitAsDefaultInstance();
  static SaveFileResponse* default_instance_;
};
// -------------------------------------------------------------------

class IsMediaFileRequest : public ::google::protobuf::Message {
 public:
  IsMediaFileRequest();
  virtual ~IsMediaFileRequest();
  
  IsMediaFileRequest(const IsMediaFileRequest& from);
  
  inline IsMediaFileRequest& operator=(const IsMediaFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const IsMediaFileRequest& default_instance();
  
  void Swap(IsMediaFileRequest* other);
  
  // implements Message ----------------------------------------------
  
  IsMediaFileRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IsMediaFileRequest& from);
  void MergeFrom(const IsMediaFileRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string filename = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  
  // @@protoc_insertion_point(class_scope:pb.tagreader.IsMediaFileRequest)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* filename_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_tagreadermessages_2eproto();
  friend void protobuf_AssignDesc_tagreadermessages_2eproto();
  friend void protobuf_ShutdownFile_tagreadermessages_2eproto();
  
  void InitAsDefaultInstance();
  static IsMediaFileRequest* default_instance_;
};
// -------------------------------------------------------------------

class IsMediaFileResponse : public ::google::protobuf::Message {
 public:
  IsMediaFileResponse();
  virtual ~IsMediaFileResponse();
  
  IsMediaFileResponse(const IsMediaFileResponse& from);
  
  inline IsMediaFileResponse& operator=(const IsMediaFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const IsMediaFileResponse& default_instance();
  
  void Swap(IsMediaFileResponse* other);
  
  // implements Message ----------------------------------------------
  
  IsMediaFileResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IsMediaFileResponse& from);
  void MergeFrom(const IsMediaFileResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);
  
  // @@protoc_insertion_point(class_scope:pb.tagreader.IsMediaFileResponse)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool success_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_tagreadermessages_2eproto();
  friend void protobuf_AssignDesc_tagreadermessages_2eproto();
  friend void protobuf_ShutdownFile_tagreadermessages_2eproto();
  
  void InitAsDefaultInstance();
  static IsMediaFileResponse* default_instance_;
};
// -------------------------------------------------------------------

class LoadEmbeddedArtRequest : public ::google::protobuf::Message {
 public:
  LoadEmbeddedArtRequest();
  virtual ~LoadEmbeddedArtRequest();
  
  LoadEmbeddedArtRequest(const LoadEmbeddedArtRequest& from);
  
  inline LoadEmbeddedArtRequest& operator=(const LoadEmbeddedArtRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadEmbeddedArtRequest& default_instance();
  
  void Swap(LoadEmbeddedArtRequest* other);
  
  // implements Message ----------------------------------------------
  
  LoadEmbeddedArtRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoadEmbeddedArtRequest& from);
  void MergeFrom(const LoadEmbeddedArtRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string filename = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  
  // @@protoc_insertion_point(class_scope:pb.tagreader.LoadEmbeddedArtRequest)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* filename_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_tagreadermessages_2eproto();
  friend void protobuf_AssignDesc_tagreadermessages_2eproto();
  friend void protobuf_ShutdownFile_tagreadermessages_2eproto();
  
  void InitAsDefaultInstance();
  static LoadEmbeddedArtRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoadEmbeddedArtResponse : public ::google::protobuf::Message {
 public:
  LoadEmbeddedArtResponse();
  virtual ~LoadEmbeddedArtResponse();
  
  LoadEmbeddedArtResponse(const LoadEmbeddedArtResponse& from);
  
  inline LoadEmbeddedArtResponse& operator=(const LoadEmbeddedArtResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadEmbeddedArtResponse& default_instance();
  
  void Swap(LoadEmbeddedArtResponse* other);
  
  // implements Message ----------------------------------------------
  
  LoadEmbeddedArtResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoadEmbeddedArtResponse& from);
  void MergeFrom(const LoadEmbeddedArtResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // @@protoc_insertion_point(class_scope:pb.tagreader.LoadEmbeddedArtResponse)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_tagreadermessages_2eproto();
  friend void protobuf_AssignDesc_tagreadermessages_2eproto();
  friend void protobuf_ShutdownFile_tagreadermessages_2eproto();
  
  void InitAsDefaultInstance();
  static LoadEmbeddedArtResponse* default_instance_;
};
// -------------------------------------------------------------------

class ReadGoogleDriveRequest : public ::google::protobuf::Message {
 public:
  ReadGoogleDriveRequest();
  virtual ~ReadGoogleDriveRequest();
  
  ReadGoogleDriveRequest(const ReadGoogleDriveRequest& from);
  
  inline ReadGoogleDriveRequest& operator=(const ReadGoogleDriveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadGoogleDriveRequest& default_instance();
  
  void Swap(ReadGoogleDriveRequest* other);
  
  // implements Message ----------------------------------------------
  
  ReadGoogleDriveRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReadGoogleDriveRequest& from);
  void MergeFrom(const ReadGoogleDriveRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string download_url = 1;
  inline bool has_download_url() const;
  inline void clear_download_url();
  static const int kDownloadUrlFieldNumber = 1;
  inline const ::std::string& download_url() const;
  inline void set_download_url(const ::std::string& value);
  inline void set_download_url(const char* value);
  inline void set_download_url(const char* value, size_t size);
  inline ::std::string* mutable_download_url();
  inline ::std::string* release_download_url();
  
  // optional string title = 2;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 2;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  
  // optional int32 size = 3;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);
  
  // optional string access_token = 4;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 4;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  
  // optional string mime_type = 5;
  inline bool has_mime_type() const;
  inline void clear_mime_type();
  static const int kMimeTypeFieldNumber = 5;
  inline const ::std::string& mime_type() const;
  inline void set_mime_type(const ::std::string& value);
  inline void set_mime_type(const char* value);
  inline void set_mime_type(const char* value, size_t size);
  inline ::std::string* mutable_mime_type();
  inline ::std::string* release_mime_type();
  
  // @@protoc_insertion_point(class_scope:pb.tagreader.ReadGoogleDriveRequest)
 private:
  inline void set_has_download_url();
  inline void clear_has_download_url();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_mime_type();
  inline void clear_has_mime_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* download_url_;
  ::std::string* title_;
  ::std::string* access_token_;
  ::std::string* mime_type_;
  ::google::protobuf::int32 size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_tagreadermessages_2eproto();
  friend void protobuf_AssignDesc_tagreadermessages_2eproto();
  friend void protobuf_ShutdownFile_tagreadermessages_2eproto();
  
  void InitAsDefaultInstance();
  static ReadGoogleDriveRequest* default_instance_;
};
// -------------------------------------------------------------------

class ReadGoogleDriveResponse : public ::google::protobuf::Message {
 public:
  ReadGoogleDriveResponse();
  virtual ~ReadGoogleDriveResponse();
  
  ReadGoogleDriveResponse(const ReadGoogleDriveResponse& from);
  
  inline ReadGoogleDriveResponse& operator=(const ReadGoogleDriveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadGoogleDriveResponse& default_instance();
  
  void Swap(ReadGoogleDriveResponse* other);
  
  // implements Message ----------------------------------------------
  
  ReadGoogleDriveResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReadGoogleDriveResponse& from);
  void MergeFrom(const ReadGoogleDriveResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .pb.tagreader.SongMetadata metadata = 1;
  inline bool has_metadata() const;
  inline void clear_metadata();
  static const int kMetadataFieldNumber = 1;
  inline const ::pb::tagreader::SongMetadata& metadata() const;
  inline ::pb::tagreader::SongMetadata* mutable_metadata();
  inline ::pb::tagreader::SongMetadata* release_metadata();
  
  // @@protoc_insertion_point(class_scope:pb.tagreader.ReadGoogleDriveResponse)
 private:
  inline void set_has_metadata();
  inline void clear_has_metadata();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::pb::tagreader::SongMetadata* metadata_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_tagreadermessages_2eproto();
  friend void protobuf_AssignDesc_tagreadermessages_2eproto();
  friend void protobuf_ShutdownFile_tagreadermessages_2eproto();
  
  void InitAsDefaultInstance();
  static ReadGoogleDriveResponse* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();
  
  Message(const Message& from);
  
  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();
  
  void Swap(Message* other);
  
  // implements Message ----------------------------------------------
  
  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional .pb.tagreader.ReadFileRequest read_file_request = 2;
  inline bool has_read_file_request() const;
  inline void clear_read_file_request();
  static const int kReadFileRequestFieldNumber = 2;
  inline const ::pb::tagreader::ReadFileRequest& read_file_request() const;
  inline ::pb::tagreader::ReadFileRequest* mutable_read_file_request();
  inline ::pb::tagreader::ReadFileRequest* release_read_file_request();
  
  // optional .pb.tagreader.ReadFileResponse read_file_response = 3;
  inline bool has_read_file_response() const;
  inline void clear_read_file_response();
  static const int kReadFileResponseFieldNumber = 3;
  inline const ::pb::tagreader::ReadFileResponse& read_file_response() const;
  inline ::pb::tagreader::ReadFileResponse* mutable_read_file_response();
  inline ::pb::tagreader::ReadFileResponse* release_read_file_response();
  
  // optional .pb.tagreader.SaveFileRequest save_file_request = 4;
  inline bool has_save_file_request() const;
  inline void clear_save_file_request();
  static const int kSaveFileRequestFieldNumber = 4;
  inline const ::pb::tagreader::SaveFileRequest& save_file_request() const;
  inline ::pb::tagreader::SaveFileRequest* mutable_save_file_request();
  inline ::pb::tagreader::SaveFileRequest* release_save_file_request();
  
  // optional .pb.tagreader.SaveFileResponse save_file_response = 5;
  inline bool has_save_file_response() const;
  inline void clear_save_file_response();
  static const int kSaveFileResponseFieldNumber = 5;
  inline const ::pb::tagreader::SaveFileResponse& save_file_response() const;
  inline ::pb::tagreader::SaveFileResponse* mutable_save_file_response();
  inline ::pb::tagreader::SaveFileResponse* release_save_file_response();
  
  // optional .pb.tagreader.IsMediaFileRequest is_media_file_request = 6;
  inline bool has_is_media_file_request() const;
  inline void clear_is_media_file_request();
  static const int kIsMediaFileRequestFieldNumber = 6;
  inline const ::pb::tagreader::IsMediaFileRequest& is_media_file_request() const;
  inline ::pb::tagreader::IsMediaFileRequest* mutable_is_media_file_request();
  inline ::pb::tagreader::IsMediaFileRequest* release_is_media_file_request();
  
  // optional .pb.tagreader.IsMediaFileResponse is_media_file_response = 7;
  inline bool has_is_media_file_response() const;
  inline void clear_is_media_file_response();
  static const int kIsMediaFileResponseFieldNumber = 7;
  inline const ::pb::tagreader::IsMediaFileResponse& is_media_file_response() const;
  inline ::pb::tagreader::IsMediaFileResponse* mutable_is_media_file_response();
  inline ::pb::tagreader::IsMediaFileResponse* release_is_media_file_response();
  
  // optional .pb.tagreader.LoadEmbeddedArtRequest load_embedded_art_request = 8;
  inline bool has_load_embedded_art_request() const;
  inline void clear_load_embedded_art_request();
  static const int kLoadEmbeddedArtRequestFieldNumber = 8;
  inline const ::pb::tagreader::LoadEmbeddedArtRequest& load_embedded_art_request() const;
  inline ::pb::tagreader::LoadEmbeddedArtRequest* mutable_load_embedded_art_request();
  inline ::pb::tagreader::LoadEmbeddedArtRequest* release_load_embedded_art_request();
  
  // optional .pb.tagreader.LoadEmbeddedArtResponse load_embedded_art_response = 9;
  inline bool has_load_embedded_art_response() const;
  inline void clear_load_embedded_art_response();
  static const int kLoadEmbeddedArtResponseFieldNumber = 9;
  inline const ::pb::tagreader::LoadEmbeddedArtResponse& load_embedded_art_response() const;
  inline ::pb::tagreader::LoadEmbeddedArtResponse* mutable_load_embedded_art_response();
  inline ::pb::tagreader::LoadEmbeddedArtResponse* release_load_embedded_art_response();
  
  // optional .pb.tagreader.ReadGoogleDriveRequest read_google_drive_request = 10;
  inline bool has_read_google_drive_request() const;
  inline void clear_read_google_drive_request();
  static const int kReadGoogleDriveRequestFieldNumber = 10;
  inline const ::pb::tagreader::ReadGoogleDriveRequest& read_google_drive_request() const;
  inline ::pb::tagreader::ReadGoogleDriveRequest* mutable_read_google_drive_request();
  inline ::pb::tagreader::ReadGoogleDriveRequest* release_read_google_drive_request();
  
  // optional .pb.tagreader.ReadGoogleDriveResponse read_google_drive_response = 11;
  inline bool has_read_google_drive_response() const;
  inline void clear_read_google_drive_response();
  static const int kReadGoogleDriveResponseFieldNumber = 11;
  inline const ::pb::tagreader::ReadGoogleDriveResponse& read_google_drive_response() const;
  inline ::pb::tagreader::ReadGoogleDriveResponse* mutable_read_google_drive_response();
  inline ::pb::tagreader::ReadGoogleDriveResponse* release_read_google_drive_response();
  
  // @@protoc_insertion_point(class_scope:pb.tagreader.Message)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_read_file_request();
  inline void clear_has_read_file_request();
  inline void set_has_read_file_response();
  inline void clear_has_read_file_response();
  inline void set_has_save_file_request();
  inline void clear_has_save_file_request();
  inline void set_has_save_file_response();
  inline void clear_has_save_file_response();
  inline void set_has_is_media_file_request();
  inline void clear_has_is_media_file_request();
  inline void set_has_is_media_file_response();
  inline void clear_has_is_media_file_response();
  inline void set_has_load_embedded_art_request();
  inline void clear_has_load_embedded_art_request();
  inline void set_has_load_embedded_art_response();
  inline void clear_has_load_embedded_art_response();
  inline void set_has_read_google_drive_request();
  inline void clear_has_read_google_drive_request();
  inline void set_has_read_google_drive_response();
  inline void clear_has_read_google_drive_response();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::pb::tagreader::ReadFileRequest* read_file_request_;
  ::pb::tagreader::ReadFileResponse* read_file_response_;
  ::pb::tagreader::SaveFileRequest* save_file_request_;
  ::pb::tagreader::SaveFileResponse* save_file_response_;
  ::pb::tagreader::IsMediaFileRequest* is_media_file_request_;
  ::pb::tagreader::IsMediaFileResponse* is_media_file_response_;
  ::pb::tagreader::LoadEmbeddedArtRequest* load_embedded_art_request_;
  ::pb::tagreader::LoadEmbeddedArtResponse* load_embedded_art_response_;
  ::pb::tagreader::ReadGoogleDriveRequest* read_google_drive_request_;
  ::pb::tagreader::ReadGoogleDriveResponse* read_google_drive_response_;
  ::google::protobuf::int32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_tagreadermessages_2eproto();
  friend void protobuf_AssignDesc_tagreadermessages_2eproto();
  friend void protobuf_ShutdownFile_tagreadermessages_2eproto();
  
  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// ===================================================================


// ===================================================================

// SongMetadata

// optional bool valid = 1;
inline bool SongMetadata::has_valid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SongMetadata::set_has_valid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SongMetadata::clear_has_valid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SongMetadata::clear_valid() {
  valid_ = false;
  clear_has_valid();
}
inline bool SongMetadata::valid() const {
  return valid_;
}
inline void SongMetadata::set_valid(bool value) {
  set_has_valid();
  valid_ = value;
}

// optional string title = 2;
inline bool SongMetadata::has_title() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SongMetadata::set_has_title() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SongMetadata::clear_has_title() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SongMetadata::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& SongMetadata::title() const {
  return *title_;
}
inline void SongMetadata::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void SongMetadata::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void SongMetadata::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SongMetadata::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* SongMetadata::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string album = 3;
inline bool SongMetadata::has_album() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SongMetadata::set_has_album() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SongMetadata::clear_has_album() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SongMetadata::clear_album() {
  if (album_ != &::google::protobuf::internal::kEmptyString) {
    album_->clear();
  }
  clear_has_album();
}
inline const ::std::string& SongMetadata::album() const {
  return *album_;
}
inline void SongMetadata::set_album(const ::std::string& value) {
  set_has_album();
  if (album_ == &::google::protobuf::internal::kEmptyString) {
    album_ = new ::std::string;
  }
  album_->assign(value);
}
inline void SongMetadata::set_album(const char* value) {
  set_has_album();
  if (album_ == &::google::protobuf::internal::kEmptyString) {
    album_ = new ::std::string;
  }
  album_->assign(value);
}
inline void SongMetadata::set_album(const char* value, size_t size) {
  set_has_album();
  if (album_ == &::google::protobuf::internal::kEmptyString) {
    album_ = new ::std::string;
  }
  album_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SongMetadata::mutable_album() {
  set_has_album();
  if (album_ == &::google::protobuf::internal::kEmptyString) {
    album_ = new ::std::string;
  }
  return album_;
}
inline ::std::string* SongMetadata::release_album() {
  clear_has_album();
  if (album_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = album_;
    album_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string artist = 4;
inline bool SongMetadata::has_artist() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SongMetadata::set_has_artist() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SongMetadata::clear_has_artist() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SongMetadata::clear_artist() {
  if (artist_ != &::google::protobuf::internal::kEmptyString) {
    artist_->clear();
  }
  clear_has_artist();
}
inline const ::std::string& SongMetadata::artist() const {
  return *artist_;
}
inline void SongMetadata::set_artist(const ::std::string& value) {
  set_has_artist();
  if (artist_ == &::google::protobuf::internal::kEmptyString) {
    artist_ = new ::std::string;
  }
  artist_->assign(value);
}
inline void SongMetadata::set_artist(const char* value) {
  set_has_artist();
  if (artist_ == &::google::protobuf::internal::kEmptyString) {
    artist_ = new ::std::string;
  }
  artist_->assign(value);
}
inline void SongMetadata::set_artist(const char* value, size_t size) {
  set_has_artist();
  if (artist_ == &::google::protobuf::internal::kEmptyString) {
    artist_ = new ::std::string;
  }
  artist_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SongMetadata::mutable_artist() {
  set_has_artist();
  if (artist_ == &::google::protobuf::internal::kEmptyString) {
    artist_ = new ::std::string;
  }
  return artist_;
}
inline ::std::string* SongMetadata::release_artist() {
  clear_has_artist();
  if (artist_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = artist_;
    artist_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string albumartist = 5;
inline bool SongMetadata::has_albumartist() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SongMetadata::set_has_albumartist() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SongMetadata::clear_has_albumartist() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SongMetadata::clear_albumartist() {
  if (albumartist_ != &::google::protobuf::internal::kEmptyString) {
    albumartist_->clear();
  }
  clear_has_albumartist();
}
inline const ::std::string& SongMetadata::albumartist() const {
  return *albumartist_;
}
inline void SongMetadata::set_albumartist(const ::std::string& value) {
  set_has_albumartist();
  if (albumartist_ == &::google::protobuf::internal::kEmptyString) {
    albumartist_ = new ::std::string;
  }
  albumartist_->assign(value);
}
inline void SongMetadata::set_albumartist(const char* value) {
  set_has_albumartist();
  if (albumartist_ == &::google::protobuf::internal::kEmptyString) {
    albumartist_ = new ::std::string;
  }
  albumartist_->assign(value);
}
inline void SongMetadata::set_albumartist(const char* value, size_t size) {
  set_has_albumartist();
  if (albumartist_ == &::google::protobuf::internal::kEmptyString) {
    albumartist_ = new ::std::string;
  }
  albumartist_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SongMetadata::mutable_albumartist() {
  set_has_albumartist();
  if (albumartist_ == &::google::protobuf::internal::kEmptyString) {
    albumartist_ = new ::std::string;
  }
  return albumartist_;
}
inline ::std::string* SongMetadata::release_albumartist() {
  clear_has_albumartist();
  if (albumartist_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = albumartist_;
    albumartist_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string composer = 6;
inline bool SongMetadata::has_composer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SongMetadata::set_has_composer() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SongMetadata::clear_has_composer() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SongMetadata::clear_composer() {
  if (composer_ != &::google::protobuf::internal::kEmptyString) {
    composer_->clear();
  }
  clear_has_composer();
}
inline const ::std::string& SongMetadata::composer() const {
  return *composer_;
}
inline void SongMetadata::set_composer(const ::std::string& value) {
  set_has_composer();
  if (composer_ == &::google::protobuf::internal::kEmptyString) {
    composer_ = new ::std::string;
  }
  composer_->assign(value);
}
inline void SongMetadata::set_composer(const char* value) {
  set_has_composer();
  if (composer_ == &::google::protobuf::internal::kEmptyString) {
    composer_ = new ::std::string;
  }
  composer_->assign(value);
}
inline void SongMetadata::set_composer(const char* value, size_t size) {
  set_has_composer();
  if (composer_ == &::google::protobuf::internal::kEmptyString) {
    composer_ = new ::std::string;
  }
  composer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SongMetadata::mutable_composer() {
  set_has_composer();
  if (composer_ == &::google::protobuf::internal::kEmptyString) {
    composer_ = new ::std::string;
  }
  return composer_;
}
inline ::std::string* SongMetadata::release_composer() {
  clear_has_composer();
  if (composer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = composer_;
    composer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 track = 7;
inline bool SongMetadata::has_track() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SongMetadata::set_has_track() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SongMetadata::clear_has_track() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SongMetadata::clear_track() {
  track_ = 0;
  clear_has_track();
}
inline ::google::protobuf::int32 SongMetadata::track() const {
  return track_;
}
inline void SongMetadata::set_track(::google::protobuf::int32 value) {
  set_has_track();
  track_ = value;
}

// optional int32 disc = 8;
inline bool SongMetadata::has_disc() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SongMetadata::set_has_disc() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SongMetadata::clear_has_disc() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SongMetadata::clear_disc() {
  disc_ = 0;
  clear_has_disc();
}
inline ::google::protobuf::int32 SongMetadata::disc() const {
  return disc_;
}
inline void SongMetadata::set_disc(::google::protobuf::int32 value) {
  set_has_disc();
  disc_ = value;
}

// optional float bpm = 9;
inline bool SongMetadata::has_bpm() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SongMetadata::set_has_bpm() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SongMetadata::clear_has_bpm() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SongMetadata::clear_bpm() {
  bpm_ = 0;
  clear_has_bpm();
}
inline float SongMetadata::bpm() const {
  return bpm_;
}
inline void SongMetadata::set_bpm(float value) {
  set_has_bpm();
  bpm_ = value;
}

// optional int32 year = 10;
inline bool SongMetadata::has_year() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SongMetadata::set_has_year() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SongMetadata::clear_has_year() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SongMetadata::clear_year() {
  year_ = 0;
  clear_has_year();
}
inline ::google::protobuf::int32 SongMetadata::year() const {
  return year_;
}
inline void SongMetadata::set_year(::google::protobuf::int32 value) {
  set_has_year();
  year_ = value;
}

// optional string genre = 11;
inline bool SongMetadata::has_genre() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SongMetadata::set_has_genre() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SongMetadata::clear_has_genre() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SongMetadata::clear_genre() {
  if (genre_ != &::google::protobuf::internal::kEmptyString) {
    genre_->clear();
  }
  clear_has_genre();
}
inline const ::std::string& SongMetadata::genre() const {
  return *genre_;
}
inline void SongMetadata::set_genre(const ::std::string& value) {
  set_has_genre();
  if (genre_ == &::google::protobuf::internal::kEmptyString) {
    genre_ = new ::std::string;
  }
  genre_->assign(value);
}
inline void SongMetadata::set_genre(const char* value) {
  set_has_genre();
  if (genre_ == &::google::protobuf::internal::kEmptyString) {
    genre_ = new ::std::string;
  }
  genre_->assign(value);
}
inline void SongMetadata::set_genre(const char* value, size_t size) {
  set_has_genre();
  if (genre_ == &::google::protobuf::internal::kEmptyString) {
    genre_ = new ::std::string;
  }
  genre_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SongMetadata::mutable_genre() {
  set_has_genre();
  if (genre_ == &::google::protobuf::internal::kEmptyString) {
    genre_ = new ::std::string;
  }
  return genre_;
}
inline ::std::string* SongMetadata::release_genre() {
  clear_has_genre();
  if (genre_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = genre_;
    genre_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string comment = 12;
inline bool SongMetadata::has_comment() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SongMetadata::set_has_comment() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SongMetadata::clear_has_comment() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SongMetadata::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& SongMetadata::comment() const {
  return *comment_;
}
inline void SongMetadata::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void SongMetadata::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void SongMetadata::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SongMetadata::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* SongMetadata::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool compilation = 13;
inline bool SongMetadata::has_compilation() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SongMetadata::set_has_compilation() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SongMetadata::clear_has_compilation() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SongMetadata::clear_compilation() {
  compilation_ = false;
  clear_has_compilation();
}
inline bool SongMetadata::compilation() const {
  return compilation_;
}
inline void SongMetadata::set_compilation(bool value) {
  set_has_compilation();
  compilation_ = value;
}

// optional float rating = 14;
inline bool SongMetadata::has_rating() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SongMetadata::set_has_rating() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SongMetadata::clear_has_rating() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SongMetadata::clear_rating() {
  rating_ = 0;
  clear_has_rating();
}
inline float SongMetadata::rating() const {
  return rating_;
}
inline void SongMetadata::set_rating(float value) {
  set_has_rating();
  rating_ = value;
}

// optional int32 playcount = 15;
inline bool SongMetadata::has_playcount() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SongMetadata::set_has_playcount() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SongMetadata::clear_has_playcount() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SongMetadata::clear_playcount() {
  playcount_ = 0;
  clear_has_playcount();
}
inline ::google::protobuf::int32 SongMetadata::playcount() const {
  return playcount_;
}
inline void SongMetadata::set_playcount(::google::protobuf::int32 value) {
  set_has_playcount();
  playcount_ = value;
}

// optional int32 skipcount = 16;
inline bool SongMetadata::has_skipcount() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SongMetadata::set_has_skipcount() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SongMetadata::clear_has_skipcount() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SongMetadata::clear_skipcount() {
  skipcount_ = 0;
  clear_has_skipcount();
}
inline ::google::protobuf::int32 SongMetadata::skipcount() const {
  return skipcount_;
}
inline void SongMetadata::set_skipcount(::google::protobuf::int32 value) {
  set_has_skipcount();
  skipcount_ = value;
}

// optional int32 lastplayed = 17;
inline bool SongMetadata::has_lastplayed() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SongMetadata::set_has_lastplayed() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SongMetadata::clear_has_lastplayed() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SongMetadata::clear_lastplayed() {
  lastplayed_ = 0;
  clear_has_lastplayed();
}
inline ::google::protobuf::int32 SongMetadata::lastplayed() const {
  return lastplayed_;
}
inline void SongMetadata::set_lastplayed(::google::protobuf::int32 value) {
  set_has_lastplayed();
  lastplayed_ = value;
}

// optional int32 score = 18;
inline bool SongMetadata::has_score() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SongMetadata::set_has_score() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SongMetadata::clear_has_score() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SongMetadata::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 SongMetadata::score() const {
  return score_;
}
inline void SongMetadata::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// optional uint64 length_nanosec = 19;
inline bool SongMetadata::has_length_nanosec() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SongMetadata::set_has_length_nanosec() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SongMetadata::clear_has_length_nanosec() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SongMetadata::clear_length_nanosec() {
  length_nanosec_ = GOOGLE_ULONGLONG(0);
  clear_has_length_nanosec();
}
inline ::google::protobuf::uint64 SongMetadata::length_nanosec() const {
  return length_nanosec_;
}
inline void SongMetadata::set_length_nanosec(::google::protobuf::uint64 value) {
  set_has_length_nanosec();
  length_nanosec_ = value;
}

// optional int32 bitrate = 20;
inline bool SongMetadata::has_bitrate() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SongMetadata::set_has_bitrate() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SongMetadata::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SongMetadata::clear_bitrate() {
  bitrate_ = 0;
  clear_has_bitrate();
}
inline ::google::protobuf::int32 SongMetadata::bitrate() const {
  return bitrate_;
}
inline void SongMetadata::set_bitrate(::google::protobuf::int32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// optional int32 samplerate = 21;
inline bool SongMetadata::has_samplerate() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SongMetadata::set_has_samplerate() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SongMetadata::clear_has_samplerate() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SongMetadata::clear_samplerate() {
  samplerate_ = 0;
  clear_has_samplerate();
}
inline ::google::protobuf::int32 SongMetadata::samplerate() const {
  return samplerate_;
}
inline void SongMetadata::set_samplerate(::google::protobuf::int32 value) {
  set_has_samplerate();
  samplerate_ = value;
}

// optional string url = 22;
inline bool SongMetadata::has_url() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SongMetadata::set_has_url() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SongMetadata::clear_has_url() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SongMetadata::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& SongMetadata::url() const {
  return *url_;
}
inline void SongMetadata::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void SongMetadata::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void SongMetadata::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SongMetadata::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* SongMetadata::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string basefilename = 23;
inline bool SongMetadata::has_basefilename() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void SongMetadata::set_has_basefilename() {
  _has_bits_[0] |= 0x00400000u;
}
inline void SongMetadata::clear_has_basefilename() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void SongMetadata::clear_basefilename() {
  if (basefilename_ != &::google::protobuf::internal::kEmptyString) {
    basefilename_->clear();
  }
  clear_has_basefilename();
}
inline const ::std::string& SongMetadata::basefilename() const {
  return *basefilename_;
}
inline void SongMetadata::set_basefilename(const ::std::string& value) {
  set_has_basefilename();
  if (basefilename_ == &::google::protobuf::internal::kEmptyString) {
    basefilename_ = new ::std::string;
  }
  basefilename_->assign(value);
}
inline void SongMetadata::set_basefilename(const char* value) {
  set_has_basefilename();
  if (basefilename_ == &::google::protobuf::internal::kEmptyString) {
    basefilename_ = new ::std::string;
  }
  basefilename_->assign(value);
}
inline void SongMetadata::set_basefilename(const char* value, size_t size) {
  set_has_basefilename();
  if (basefilename_ == &::google::protobuf::internal::kEmptyString) {
    basefilename_ = new ::std::string;
  }
  basefilename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SongMetadata::mutable_basefilename() {
  set_has_basefilename();
  if (basefilename_ == &::google::protobuf::internal::kEmptyString) {
    basefilename_ = new ::std::string;
  }
  return basefilename_;
}
inline ::std::string* SongMetadata::release_basefilename() {
  clear_has_basefilename();
  if (basefilename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = basefilename_;
    basefilename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 mtime = 24;
inline bool SongMetadata::has_mtime() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void SongMetadata::set_has_mtime() {
  _has_bits_[0] |= 0x00800000u;
}
inline void SongMetadata::clear_has_mtime() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void SongMetadata::clear_mtime() {
  mtime_ = 0;
  clear_has_mtime();
}
inline ::google::protobuf::int32 SongMetadata::mtime() const {
  return mtime_;
}
inline void SongMetadata::set_mtime(::google::protobuf::int32 value) {
  set_has_mtime();
  mtime_ = value;
}

// optional int32 ctime = 25;
inline bool SongMetadata::has_ctime() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void SongMetadata::set_has_ctime() {
  _has_bits_[0] |= 0x01000000u;
}
inline void SongMetadata::clear_has_ctime() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void SongMetadata::clear_ctime() {
  ctime_ = 0;
  clear_has_ctime();
}
inline ::google::protobuf::int32 SongMetadata::ctime() const {
  return ctime_;
}
inline void SongMetadata::set_ctime(::google::protobuf::int32 value) {
  set_has_ctime();
  ctime_ = value;
}

// optional int32 filesize = 26;
inline bool SongMetadata::has_filesize() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void SongMetadata::set_has_filesize() {
  _has_bits_[0] |= 0x02000000u;
}
inline void SongMetadata::clear_has_filesize() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void SongMetadata::clear_filesize() {
  filesize_ = 0;
  clear_has_filesize();
}
inline ::google::protobuf::int32 SongMetadata::filesize() const {
  return filesize_;
}
inline void SongMetadata::set_filesize(::google::protobuf::int32 value) {
  set_has_filesize();
  filesize_ = value;
}

// optional bool suspicious_tags = 27;
inline bool SongMetadata::has_suspicious_tags() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void SongMetadata::set_has_suspicious_tags() {
  _has_bits_[0] |= 0x04000000u;
}
inline void SongMetadata::clear_has_suspicious_tags() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void SongMetadata::clear_suspicious_tags() {
  suspicious_tags_ = false;
  clear_has_suspicious_tags();
}
inline bool SongMetadata::suspicious_tags() const {
  return suspicious_tags_;
}
inline void SongMetadata::set_suspicious_tags(bool value) {
  set_has_suspicious_tags();
  suspicious_tags_ = value;
}

// optional string art_automatic = 28;
inline bool SongMetadata::has_art_automatic() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void SongMetadata::set_has_art_automatic() {
  _has_bits_[0] |= 0x08000000u;
}
inline void SongMetadata::clear_has_art_automatic() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void SongMetadata::clear_art_automatic() {
  if (art_automatic_ != &::google::protobuf::internal::kEmptyString) {
    art_automatic_->clear();
  }
  clear_has_art_automatic();
}
inline const ::std::string& SongMetadata::art_automatic() const {
  return *art_automatic_;
}
inline void SongMetadata::set_art_automatic(const ::std::string& value) {
  set_has_art_automatic();
  if (art_automatic_ == &::google::protobuf::internal::kEmptyString) {
    art_automatic_ = new ::std::string;
  }
  art_automatic_->assign(value);
}
inline void SongMetadata::set_art_automatic(const char* value) {
  set_has_art_automatic();
  if (art_automatic_ == &::google::protobuf::internal::kEmptyString) {
    art_automatic_ = new ::std::string;
  }
  art_automatic_->assign(value);
}
inline void SongMetadata::set_art_automatic(const char* value, size_t size) {
  set_has_art_automatic();
  if (art_automatic_ == &::google::protobuf::internal::kEmptyString) {
    art_automatic_ = new ::std::string;
  }
  art_automatic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SongMetadata::mutable_art_automatic() {
  set_has_art_automatic();
  if (art_automatic_ == &::google::protobuf::internal::kEmptyString) {
    art_automatic_ = new ::std::string;
  }
  return art_automatic_;
}
inline ::std::string* SongMetadata::release_art_automatic() {
  clear_has_art_automatic();
  if (art_automatic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = art_automatic_;
    art_automatic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .pb.tagreader.SongMetadata.Type type = 29;
inline bool SongMetadata::has_type() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void SongMetadata::set_has_type() {
  _has_bits_[0] |= 0x10000000u;
}
inline void SongMetadata::clear_has_type() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void SongMetadata::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::pb::tagreader::SongMetadata_Type SongMetadata::type() const {
  return static_cast< ::pb::tagreader::SongMetadata_Type >(type_);
}
inline void SongMetadata::set_type(::pb::tagreader::SongMetadata_Type value) {
  GOOGLE_DCHECK(::pb::tagreader::SongMetadata_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// ReadFileRequest

// optional string filename = 1;
inline bool ReadFileRequest::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReadFileRequest::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReadFileRequest::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReadFileRequest::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& ReadFileRequest::filename() const {
  return *filename_;
}
inline void ReadFileRequest::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void ReadFileRequest::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void ReadFileRequest::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReadFileRequest::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* ReadFileRequest::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ReadFileResponse

// optional .pb.tagreader.SongMetadata metadata = 1;
inline bool ReadFileResponse::has_metadata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReadFileResponse::set_has_metadata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReadFileResponse::clear_has_metadata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReadFileResponse::clear_metadata() {
  if (metadata_ != NULL) metadata_->::pb::tagreader::SongMetadata::Clear();
  clear_has_metadata();
}
inline const ::pb::tagreader::SongMetadata& ReadFileResponse::metadata() const {
  return metadata_ != NULL ? *metadata_ : *default_instance_->metadata_;
}
inline ::pb::tagreader::SongMetadata* ReadFileResponse::mutable_metadata() {
  set_has_metadata();
  if (metadata_ == NULL) metadata_ = new ::pb::tagreader::SongMetadata;
  return metadata_;
}
inline ::pb::tagreader::SongMetadata* ReadFileResponse::release_metadata() {
  clear_has_metadata();
  ::pb::tagreader::SongMetadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// SaveFileRequest

// optional string filename = 1;
inline bool SaveFileRequest::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SaveFileRequest::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SaveFileRequest::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SaveFileRequest::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& SaveFileRequest::filename() const {
  return *filename_;
}
inline void SaveFileRequest::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void SaveFileRequest::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void SaveFileRequest::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SaveFileRequest::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* SaveFileRequest::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .pb.tagreader.SongMetadata metadata = 2;
inline bool SaveFileRequest::has_metadata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SaveFileRequest::set_has_metadata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SaveFileRequest::clear_has_metadata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SaveFileRequest::clear_metadata() {
  if (metadata_ != NULL) metadata_->::pb::tagreader::SongMetadata::Clear();
  clear_has_metadata();
}
inline const ::pb::tagreader::SongMetadata& SaveFileRequest::metadata() const {
  return metadata_ != NULL ? *metadata_ : *default_instance_->metadata_;
}
inline ::pb::tagreader::SongMetadata* SaveFileRequest::mutable_metadata() {
  set_has_metadata();
  if (metadata_ == NULL) metadata_ = new ::pb::tagreader::SongMetadata;
  return metadata_;
}
inline ::pb::tagreader::SongMetadata* SaveFileRequest::release_metadata() {
  clear_has_metadata();
  ::pb::tagreader::SongMetadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// SaveFileResponse

// optional bool success = 1;
inline bool SaveFileResponse::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SaveFileResponse::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SaveFileResponse::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SaveFileResponse::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool SaveFileResponse::success() const {
  return success_;
}
inline void SaveFileResponse::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// -------------------------------------------------------------------

// IsMediaFileRequest

// optional string filename = 1;
inline bool IsMediaFileRequest::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IsMediaFileRequest::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IsMediaFileRequest::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IsMediaFileRequest::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& IsMediaFileRequest::filename() const {
  return *filename_;
}
inline void IsMediaFileRequest::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void IsMediaFileRequest::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void IsMediaFileRequest::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IsMediaFileRequest::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* IsMediaFileRequest::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// IsMediaFileResponse

// optional bool success = 1;
inline bool IsMediaFileResponse::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IsMediaFileResponse::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IsMediaFileResponse::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IsMediaFileResponse::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool IsMediaFileResponse::success() const {
  return success_;
}
inline void IsMediaFileResponse::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// -------------------------------------------------------------------

// LoadEmbeddedArtRequest

// optional string filename = 1;
inline bool LoadEmbeddedArtRequest::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadEmbeddedArtRequest::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadEmbeddedArtRequest::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadEmbeddedArtRequest::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& LoadEmbeddedArtRequest::filename() const {
  return *filename_;
}
inline void LoadEmbeddedArtRequest::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void LoadEmbeddedArtRequest::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void LoadEmbeddedArtRequest::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadEmbeddedArtRequest::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* LoadEmbeddedArtRequest::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LoadEmbeddedArtResponse

// optional bytes data = 1;
inline bool LoadEmbeddedArtResponse::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadEmbeddedArtResponse::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadEmbeddedArtResponse::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadEmbeddedArtResponse::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& LoadEmbeddedArtResponse::data() const {
  return *data_;
}
inline void LoadEmbeddedArtResponse::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void LoadEmbeddedArtResponse::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void LoadEmbeddedArtResponse::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadEmbeddedArtResponse::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* LoadEmbeddedArtResponse::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ReadGoogleDriveRequest

// optional string download_url = 1;
inline bool ReadGoogleDriveRequest::has_download_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReadGoogleDriveRequest::set_has_download_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReadGoogleDriveRequest::clear_has_download_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReadGoogleDriveRequest::clear_download_url() {
  if (download_url_ != &::google::protobuf::internal::kEmptyString) {
    download_url_->clear();
  }
  clear_has_download_url();
}
inline const ::std::string& ReadGoogleDriveRequest::download_url() const {
  return *download_url_;
}
inline void ReadGoogleDriveRequest::set_download_url(const ::std::string& value) {
  set_has_download_url();
  if (download_url_ == &::google::protobuf::internal::kEmptyString) {
    download_url_ = new ::std::string;
  }
  download_url_->assign(value);
}
inline void ReadGoogleDriveRequest::set_download_url(const char* value) {
  set_has_download_url();
  if (download_url_ == &::google::protobuf::internal::kEmptyString) {
    download_url_ = new ::std::string;
  }
  download_url_->assign(value);
}
inline void ReadGoogleDriveRequest::set_download_url(const char* value, size_t size) {
  set_has_download_url();
  if (download_url_ == &::google::protobuf::internal::kEmptyString) {
    download_url_ = new ::std::string;
  }
  download_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReadGoogleDriveRequest::mutable_download_url() {
  set_has_download_url();
  if (download_url_ == &::google::protobuf::internal::kEmptyString) {
    download_url_ = new ::std::string;
  }
  return download_url_;
}
inline ::std::string* ReadGoogleDriveRequest::release_download_url() {
  clear_has_download_url();
  if (download_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = download_url_;
    download_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string title = 2;
inline bool ReadGoogleDriveRequest::has_title() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReadGoogleDriveRequest::set_has_title() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReadGoogleDriveRequest::clear_has_title() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReadGoogleDriveRequest::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& ReadGoogleDriveRequest::title() const {
  return *title_;
}
inline void ReadGoogleDriveRequest::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void ReadGoogleDriveRequest::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void ReadGoogleDriveRequest::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReadGoogleDriveRequest::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* ReadGoogleDriveRequest::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 size = 3;
inline bool ReadGoogleDriveRequest::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReadGoogleDriveRequest::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReadGoogleDriveRequest::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReadGoogleDriveRequest::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 ReadGoogleDriveRequest::size() const {
  return size_;
}
inline void ReadGoogleDriveRequest::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// optional string access_token = 4;
inline bool ReadGoogleDriveRequest::has_access_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReadGoogleDriveRequest::set_has_access_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReadGoogleDriveRequest::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReadGoogleDriveRequest::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::kEmptyString) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& ReadGoogleDriveRequest::access_token() const {
  return *access_token_;
}
inline void ReadGoogleDriveRequest::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
}
inline void ReadGoogleDriveRequest::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
}
inline void ReadGoogleDriveRequest::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReadGoogleDriveRequest::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  return access_token_;
}
inline ::std::string* ReadGoogleDriveRequest::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string mime_type = 5;
inline bool ReadGoogleDriveRequest::has_mime_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReadGoogleDriveRequest::set_has_mime_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReadGoogleDriveRequest::clear_has_mime_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReadGoogleDriveRequest::clear_mime_type() {
  if (mime_type_ != &::google::protobuf::internal::kEmptyString) {
    mime_type_->clear();
  }
  clear_has_mime_type();
}
inline const ::std::string& ReadGoogleDriveRequest::mime_type() const {
  return *mime_type_;
}
inline void ReadGoogleDriveRequest::set_mime_type(const ::std::string& value) {
  set_has_mime_type();
  if (mime_type_ == &::google::protobuf::internal::kEmptyString) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(value);
}
inline void ReadGoogleDriveRequest::set_mime_type(const char* value) {
  set_has_mime_type();
  if (mime_type_ == &::google::protobuf::internal::kEmptyString) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(value);
}
inline void ReadGoogleDriveRequest::set_mime_type(const char* value, size_t size) {
  set_has_mime_type();
  if (mime_type_ == &::google::protobuf::internal::kEmptyString) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReadGoogleDriveRequest::mutable_mime_type() {
  set_has_mime_type();
  if (mime_type_ == &::google::protobuf::internal::kEmptyString) {
    mime_type_ = new ::std::string;
  }
  return mime_type_;
}
inline ::std::string* ReadGoogleDriveRequest::release_mime_type() {
  clear_has_mime_type();
  if (mime_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mime_type_;
    mime_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ReadGoogleDriveResponse

// optional .pb.tagreader.SongMetadata metadata = 1;
inline bool ReadGoogleDriveResponse::has_metadata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReadGoogleDriveResponse::set_has_metadata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReadGoogleDriveResponse::clear_has_metadata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReadGoogleDriveResponse::clear_metadata() {
  if (metadata_ != NULL) metadata_->::pb::tagreader::SongMetadata::Clear();
  clear_has_metadata();
}
inline const ::pb::tagreader::SongMetadata& ReadGoogleDriveResponse::metadata() const {
  return metadata_ != NULL ? *metadata_ : *default_instance_->metadata_;
}
inline ::pb::tagreader::SongMetadata* ReadGoogleDriveResponse::mutable_metadata() {
  set_has_metadata();
  if (metadata_ == NULL) metadata_ = new ::pb::tagreader::SongMetadata;
  return metadata_;
}
inline ::pb::tagreader::SongMetadata* ReadGoogleDriveResponse::release_metadata() {
  clear_has_metadata();
  ::pb::tagreader::SongMetadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Message

// optional int32 id = 1;
inline bool Message::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Message::id() const {
  return id_;
}
inline void Message::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional .pb.tagreader.ReadFileRequest read_file_request = 2;
inline bool Message::has_read_file_request() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_read_file_request() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_read_file_request() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_read_file_request() {
  if (read_file_request_ != NULL) read_file_request_->::pb::tagreader::ReadFileRequest::Clear();
  clear_has_read_file_request();
}
inline const ::pb::tagreader::ReadFileRequest& Message::read_file_request() const {
  return read_file_request_ != NULL ? *read_file_request_ : *default_instance_->read_file_request_;
}
inline ::pb::tagreader::ReadFileRequest* Message::mutable_read_file_request() {
  set_has_read_file_request();
  if (read_file_request_ == NULL) read_file_request_ = new ::pb::tagreader::ReadFileRequest;
  return read_file_request_;
}
inline ::pb::tagreader::ReadFileRequest* Message::release_read_file_request() {
  clear_has_read_file_request();
  ::pb::tagreader::ReadFileRequest* temp = read_file_request_;
  read_file_request_ = NULL;
  return temp;
}

// optional .pb.tagreader.ReadFileResponse read_file_response = 3;
inline bool Message::has_read_file_response() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_read_file_response() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_read_file_response() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_read_file_response() {
  if (read_file_response_ != NULL) read_file_response_->::pb::tagreader::ReadFileResponse::Clear();
  clear_has_read_file_response();
}
inline const ::pb::tagreader::ReadFileResponse& Message::read_file_response() const {
  return read_file_response_ != NULL ? *read_file_response_ : *default_instance_->read_file_response_;
}
inline ::pb::tagreader::ReadFileResponse* Message::mutable_read_file_response() {
  set_has_read_file_response();
  if (read_file_response_ == NULL) read_file_response_ = new ::pb::tagreader::ReadFileResponse;
  return read_file_response_;
}
inline ::pb::tagreader::ReadFileResponse* Message::release_read_file_response() {
  clear_has_read_file_response();
  ::pb::tagreader::ReadFileResponse* temp = read_file_response_;
  read_file_response_ = NULL;
  return temp;
}

// optional .pb.tagreader.SaveFileRequest save_file_request = 4;
inline bool Message::has_save_file_request() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_save_file_request() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_save_file_request() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_save_file_request() {
  if (save_file_request_ != NULL) save_file_request_->::pb::tagreader::SaveFileRequest::Clear();
  clear_has_save_file_request();
}
inline const ::pb::tagreader::SaveFileRequest& Message::save_file_request() const {
  return save_file_request_ != NULL ? *save_file_request_ : *default_instance_->save_file_request_;
}
inline ::pb::tagreader::SaveFileRequest* Message::mutable_save_file_request() {
  set_has_save_file_request();
  if (save_file_request_ == NULL) save_file_request_ = new ::pb::tagreader::SaveFileRequest;
  return save_file_request_;
}
inline ::pb::tagreader::SaveFileRequest* Message::release_save_file_request() {
  clear_has_save_file_request();
  ::pb::tagreader::SaveFileRequest* temp = save_file_request_;
  save_file_request_ = NULL;
  return temp;
}

// optional .pb.tagreader.SaveFileResponse save_file_response = 5;
inline bool Message::has_save_file_response() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message::set_has_save_file_response() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message::clear_has_save_file_response() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message::clear_save_file_response() {
  if (save_file_response_ != NULL) save_file_response_->::pb::tagreader::SaveFileResponse::Clear();
  clear_has_save_file_response();
}
inline const ::pb::tagreader::SaveFileResponse& Message::save_file_response() const {
  return save_file_response_ != NULL ? *save_file_response_ : *default_instance_->save_file_response_;
}
inline ::pb::tagreader::SaveFileResponse* Message::mutable_save_file_response() {
  set_has_save_file_response();
  if (save_file_response_ == NULL) save_file_response_ = new ::pb::tagreader::SaveFileResponse;
  return save_file_response_;
}
inline ::pb::tagreader::SaveFileResponse* Message::release_save_file_response() {
  clear_has_save_file_response();
  ::pb::tagreader::SaveFileResponse* temp = save_file_response_;
  save_file_response_ = NULL;
  return temp;
}

// optional .pb.tagreader.IsMediaFileRequest is_media_file_request = 6;
inline bool Message::has_is_media_file_request() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message::set_has_is_media_file_request() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message::clear_has_is_media_file_request() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message::clear_is_media_file_request() {
  if (is_media_file_request_ != NULL) is_media_file_request_->::pb::tagreader::IsMediaFileRequest::Clear();
  clear_has_is_media_file_request();
}
inline const ::pb::tagreader::IsMediaFileRequest& Message::is_media_file_request() const {
  return is_media_file_request_ != NULL ? *is_media_file_request_ : *default_instance_->is_media_file_request_;
}
inline ::pb::tagreader::IsMediaFileRequest* Message::mutable_is_media_file_request() {
  set_has_is_media_file_request();
  if (is_media_file_request_ == NULL) is_media_file_request_ = new ::pb::tagreader::IsMediaFileRequest;
  return is_media_file_request_;
}
inline ::pb::tagreader::IsMediaFileRequest* Message::release_is_media_file_request() {
  clear_has_is_media_file_request();
  ::pb::tagreader::IsMediaFileRequest* temp = is_media_file_request_;
  is_media_file_request_ = NULL;
  return temp;
}

// optional .pb.tagreader.IsMediaFileResponse is_media_file_response = 7;
inline bool Message::has_is_media_file_response() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Message::set_has_is_media_file_response() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Message::clear_has_is_media_file_response() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Message::clear_is_media_file_response() {
  if (is_media_file_response_ != NULL) is_media_file_response_->::pb::tagreader::IsMediaFileResponse::Clear();
  clear_has_is_media_file_response();
}
inline const ::pb::tagreader::IsMediaFileResponse& Message::is_media_file_response() const {
  return is_media_file_response_ != NULL ? *is_media_file_response_ : *default_instance_->is_media_file_response_;
}
inline ::pb::tagreader::IsMediaFileResponse* Message::mutable_is_media_file_response() {
  set_has_is_media_file_response();
  if (is_media_file_response_ == NULL) is_media_file_response_ = new ::pb::tagreader::IsMediaFileResponse;
  return is_media_file_response_;
}
inline ::pb::tagreader::IsMediaFileResponse* Message::release_is_media_file_response() {
  clear_has_is_media_file_response();
  ::pb::tagreader::IsMediaFileResponse* temp = is_media_file_response_;
  is_media_file_response_ = NULL;
  return temp;
}

// optional .pb.tagreader.LoadEmbeddedArtRequest load_embedded_art_request = 8;
inline bool Message::has_load_embedded_art_request() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Message::set_has_load_embedded_art_request() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Message::clear_has_load_embedded_art_request() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Message::clear_load_embedded_art_request() {
  if (load_embedded_art_request_ != NULL) load_embedded_art_request_->::pb::tagreader::LoadEmbeddedArtRequest::Clear();
  clear_has_load_embedded_art_request();
}
inline const ::pb::tagreader::LoadEmbeddedArtRequest& Message::load_embedded_art_request() const {
  return load_embedded_art_request_ != NULL ? *load_embedded_art_request_ : *default_instance_->load_embedded_art_request_;
}
inline ::pb::tagreader::LoadEmbeddedArtRequest* Message::mutable_load_embedded_art_request() {
  set_has_load_embedded_art_request();
  if (load_embedded_art_request_ == NULL) load_embedded_art_request_ = new ::pb::tagreader::LoadEmbeddedArtRequest;
  return load_embedded_art_request_;
}
inline ::pb::tagreader::LoadEmbeddedArtRequest* Message::release_load_embedded_art_request() {
  clear_has_load_embedded_art_request();
  ::pb::tagreader::LoadEmbeddedArtRequest* temp = load_embedded_art_request_;
  load_embedded_art_request_ = NULL;
  return temp;
}

// optional .pb.tagreader.LoadEmbeddedArtResponse load_embedded_art_response = 9;
inline bool Message::has_load_embedded_art_response() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Message::set_has_load_embedded_art_response() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Message::clear_has_load_embedded_art_response() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Message::clear_load_embedded_art_response() {
  if (load_embedded_art_response_ != NULL) load_embedded_art_response_->::pb::tagreader::LoadEmbeddedArtResponse::Clear();
  clear_has_load_embedded_art_response();
}
inline const ::pb::tagreader::LoadEmbeddedArtResponse& Message::load_embedded_art_response() const {
  return load_embedded_art_response_ != NULL ? *load_embedded_art_response_ : *default_instance_->load_embedded_art_response_;
}
inline ::pb::tagreader::LoadEmbeddedArtResponse* Message::mutable_load_embedded_art_response() {
  set_has_load_embedded_art_response();
  if (load_embedded_art_response_ == NULL) load_embedded_art_response_ = new ::pb::tagreader::LoadEmbeddedArtResponse;
  return load_embedded_art_response_;
}
inline ::pb::tagreader::LoadEmbeddedArtResponse* Message::release_load_embedded_art_response() {
  clear_has_load_embedded_art_response();
  ::pb::tagreader::LoadEmbeddedArtResponse* temp = load_embedded_art_response_;
  load_embedded_art_response_ = NULL;
  return temp;
}

// optional .pb.tagreader.ReadGoogleDriveRequest read_google_drive_request = 10;
inline bool Message::has_read_google_drive_request() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Message::set_has_read_google_drive_request() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Message::clear_has_read_google_drive_request() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Message::clear_read_google_drive_request() {
  if (read_google_drive_request_ != NULL) read_google_drive_request_->::pb::tagreader::ReadGoogleDriveRequest::Clear();
  clear_has_read_google_drive_request();
}
inline const ::pb::tagreader::ReadGoogleDriveRequest& Message::read_google_drive_request() const {
  return read_google_drive_request_ != NULL ? *read_google_drive_request_ : *default_instance_->read_google_drive_request_;
}
inline ::pb::tagreader::ReadGoogleDriveRequest* Message::mutable_read_google_drive_request() {
  set_has_read_google_drive_request();
  if (read_google_drive_request_ == NULL) read_google_drive_request_ = new ::pb::tagreader::ReadGoogleDriveRequest;
  return read_google_drive_request_;
}
inline ::pb::tagreader::ReadGoogleDriveRequest* Message::release_read_google_drive_request() {
  clear_has_read_google_drive_request();
  ::pb::tagreader::ReadGoogleDriveRequest* temp = read_google_drive_request_;
  read_google_drive_request_ = NULL;
  return temp;
}

// optional .pb.tagreader.ReadGoogleDriveResponse read_google_drive_response = 11;
inline bool Message::has_read_google_drive_response() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Message::set_has_read_google_drive_response() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Message::clear_has_read_google_drive_response() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Message::clear_read_google_drive_response() {
  if (read_google_drive_response_ != NULL) read_google_drive_response_->::pb::tagreader::ReadGoogleDriveResponse::Clear();
  clear_has_read_google_drive_response();
}
inline const ::pb::tagreader::ReadGoogleDriveResponse& Message::read_google_drive_response() const {
  return read_google_drive_response_ != NULL ? *read_google_drive_response_ : *default_instance_->read_google_drive_response_;
}
inline ::pb::tagreader::ReadGoogleDriveResponse* Message::mutable_read_google_drive_response() {
  set_has_read_google_drive_response();
  if (read_google_drive_response_ == NULL) read_google_drive_response_ = new ::pb::tagreader::ReadGoogleDriveResponse;
  return read_google_drive_response_;
}
inline ::pb::tagreader::ReadGoogleDriveResponse* Message::release_read_google_drive_response() {
  clear_has_read_google_drive_response();
  ::pb::tagreader::ReadGoogleDriveResponse* temp = read_google_drive_response_;
  read_google_drive_response_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace tagreader
}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::tagreader::SongMetadata_Type>() {
  return ::pb::tagreader::SongMetadata_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tagreadermessages_2eproto__INCLUDED
